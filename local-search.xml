<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>DW分解（Dantzig-Wolfe decomposition）和benders分解</title>
    <link href="/2023/01/12/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/DW%E5%88%86%E8%A7%A3%EF%BC%88Dantzig-Wolfe%20decomposition%EF%BC%89%E5%92%8Cbenders%E5%88%86%E8%A7%A3/"/>
    <url>/2023/01/12/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/DW%E5%88%86%E8%A7%A3%EF%BC%88Dantzig-Wolfe%20decomposition%EF%BC%89%E5%92%8Cbenders%E5%88%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>#! https://zhuanlan.zhihu.com/p/598626208 # DW分解（Dantzig-Wolfedecomposition）和benders分解</p><h2 id="dw分解dantzig-wolfe-decomposition">DW分解（Dantzig-Wolfedecomposition）</h2><p>对于标准形式的线性规划，也就是</p><p><span class="math display">\[\min c^T x \\    {s.t.}\left \{        \begin{array}{l}            Ax = b\\            x\ge 0        \end{array}        \right.\]</span></p><p>如果矩阵<spanclass="math inline">\(A\)</span>存在一些特点，是有助于我们解决问题的。特别的，如果矩阵形如</p><figure><imgsrc="images/cb29a30ca926c601546aad8c85e0f2be181a3464773689f5da8aa0015030b268.png"alt="矩阵形式" /><figcaption aria-hidden="true">矩阵形式</figcaption></figure><p>也就是存在大量“整块儿”的零矩阵。在这种情况下问题可以写为</p><p><span class="math display">\[\min c_1^T x_1 + c_2^T x_2 \\    {s.t.}\left \{        \begin{array}{l}            D_1x_1 + D_2x_2 = b_0\\            F_1x_1 = b_1\\            F_2x_2 = b_2\\            x_1,x_2\ge 0        \end{array}        \right.\]</span></p><p>其中<span class="math inline">\(b_0 \in R^{m_0}\)</span>，<spanclass="math inline">\(b_1 \in R^{m_1}\)</span>，<spanclass="math inline">\(b_2\in R^{m_2}\)</span>。如果<spanclass="math inline">\(m_1,m_2 \ggm_0\)</span>，也就是零矩阵的区域非常大，我们可以使用DW分解来高效的求解。它的本质是利用多面体表示定理（MinkowskiResolution Theorem），把<span class="math inline">\(x_1\)</span>和<spanclass="math inline">\(x_2\)</span>分别进行表示，这样可以转化掉<spanclass="math inline">\(F_1x_1=b_1\)</span>和<spanclass="math inline">\(F_2x_2=b_2\)</span>这两个约束。但是会引入非常多新的变量。具体的</p><p>对于多面体（此处其实是超平面）</p><p><span class="math display">\[\Omega_i  = \{x|F_ix = b_i\}\]</span></p><p>我们可以利用Minkowski ResolutionTheorem，也就是多面体表示定理，把<spanclass="math inline">\(x_1,x_2\)</span>利用多面体的极点和极线表示出来</p><p><span class="math display">\[x_i = \sum_{p^j \in P_{i}} \lambda_i^jp^j + \sum_{r^k\in R_i}\theta_i^kr^k,\quad \sum_{p^j \in P_{i}} \lambda_i^j = 1\]</span></p><p>其中<span class="math inline">\(P_i\)</span>是多面体<spanclass="math inline">\(\Omega_i\)</span>的极点集，<spanclass="math inline">\(R_i\)</span>是多面体<spanclass="math inline">\(\Omega_i\)</span>的极线集。基于此，就能写出分解后问题</p><p><span class="math display">\[\min c_1^T(\sum_{p^j \in P_{1}} \lambda_1^jp^j + \sum_{r^k\in R_1}\theta_1^kr^k) + c_2^T (\sum_{p^j \in P_{2}} \lambda_2^jp^j +\sum_{r^k\in R_2} \theta_2^kr^k)  \\    {s.t.}\left \{        \begin{array}{l}            D_1(\sum_{p^j \in P_{1}} \lambda_1^jp^j + \sum_{r^k\in R_1}\theta_1^kr^k) + D_2(\sum_{p^j \in P_{2}} \lambda_2^jp^j + \sum_{r^k\inR_2} \theta_2^kr^k) = b_0\\            \sum_{p^j \in P_{i}} \lambda_i^j = 1, \ i=1,2\\            \lambda_i^j,\theta_i^k\ge 0        \end{array}        \right.\]</span></p><p>注意到这个问题变的只有<spanclass="math inline">\(m_0+2\)</span>个等式约束。当然相应的，变量多了很多。我们知道对于这种问题，使用列生成算法是一个很好的方案。</p><p>当然，这种方式是可以推广的。首先，它不仅可以处理这种把矩阵分解成两块的情况，更多块也是可以的，也就是把原问题分解成</p><p><span class="math display">\[\min \sum_i c_i^T x_i \\    {s.t.}\left \{        \begin{array}{l}            \sum_i D_ix_i = b_0\\            F_ix_i = b_i\\            x_i\ge 0        \end{array}        \right.\]</span></p><p>另一方面，它不止能处理等式情况，实际上只要相应集合是可以写成多面体的形式，就可以使用此方法。</p><h2 id="benders分解">benders分解</h2><p>DW分解是利用列生成的方式对问题进行分解，对偶的，benders分解利用行生成的方式解决问题。实际上，benders分解和DW分解某种程度上也存在一种对偶性。</p><p>考虑问题P</p><p><span class="math display">\[\min f(x,y) \\    {s.t.}\left \{        \begin{array}{l}            G(x,y) \ge 0  \\            x\in X,y\in Y (X\subseteq R^{n_1},Y\subseteq R^{n_2})        \end{array}        \right.\]</span></p><p>其中，x为普通变量，y为特殊变量，一般为比x更复杂的变量。比如常见的x为普通变量，y为整数变量。</p><p>当y被暂时的固定下来时，问题P就可以被分解为独立的子问题，这些问题可以被并行求解。并且由于这些子问题只包含普通变量，它们是好求解的；甚至可以被reduce到已有的问题（背包问题、最短路问题、普通线性规划）。这两此决策往往是上下层的关系。</p><p>基于这个思想，我们可以把问题重写为 <span class="math display">\[        \min_y\ [\min_x f(x,y)\ s.t. G(x,y) \ge 0 , x\in X]\\        s.t.\ y\in Y\cap V\]</span> 或者说，更清晰的 <span class="math display">\[        \min_y\ v(y)\\        s.t.\ y\in Y\cap V\]</span></p><p>其中<span class="math inline">\(v(y)=\min_x f(x,y)\ s.t. G(x,y) \ge 0, x\in X\)</span>，<span class="math inline">\(Y = \{y:G(x,y)\ge 0\ for\ some \ x \in X \}\)</span></p><p>在传统的Benders分解中，要求<spanclass="math inline">\(v(y)\)</span>是一个线性规划问题。</p><p>如果我们假设子问题<spanclass="math inline">\(v(y)\)</span>是一个线性规划问题，也就是 <spanclass="math display">\[    v(y) = \min_{x\in X} f(x,y) = \min_{x\in X} c^T x + \psi(y)\\    s.t. \ G(x,y) = Ax + g(y) + b \ge 0,x\ge 0\]</span></p><p>写出它的对偶问题 <span class="math display">\[    v(y) = \max_{u\ge0} \psi(y) - u^T g(y) - u^T b\\    s.t. \ c^T - u^T A \ge 0,u\ge 0\]</span></p><p>注意一些对偶问题的性质：对偶问题的任意目标值是原问题任意目标值的下界（这也是要取对偶问题的关键之一）；对偶问题无界-&gt;原问题无解。</p><p>考虑对偶问题的极值点集<spanclass="math inline">\(\Omega_p\)</span>和极值束集<spanclass="math inline">\(\Omega_r\)</span> 对于极值点集，我们有 <spanclass="math display">\[    v(y) \ge \psi(y) - u^T (g(y)+b),\forall u \in \Omega_p\]</span> 对于极值束集，当<span class="math inline">\(u\in\Omega_r\)</span>，对偶问题无界，原问题无解。 到此为止，主问题<spanclass="math inline">\(\min_{y\in Y}v(y)\)</span>就可以写成关于y的带大量约束的问题，其中约束包括种 <spanclass="math display">\[      v(y) \ge \psi(y) - u^T (g(y)+b) , \forall u\in \Omega_p \quad最优性约束\\    - u^T (g(y)+b) \le 0, \forall u \in \Omega_r \quad 可行性约束\]</span></p><p>现在我们把原问题转化成了一个含有大量约束的问题，不过问题中不再含有x了。一个非常有用的洞见是绝大多数约束都是不起作用的，只需要找到起作用的约束即可因此我们考虑把这些约束全部松弛掉，然后慢慢加入约束来得到可行解。我们称这个松弛问题为RMP。</p><p>求解RMP，得到<span class="math inline">\(\bar{y}\)</span>和<spanclass="math inline">\(v(\bar{y})\)</span>，如果子问题有界，且目标函数值小于等于<spanclass="math inline">\(v(\bar{y})\)</span>，这就得到了最优解。若目标函数值大于<spanclass="math inline">\(v(\bar{y})\)</span>，则添加最优性约束。若子问题无界，则添加可行性约束。</p><p>考虑子问题不是线性规划的形式，我们也可以借用Benders分解的思想。比如使用logitcut来割平面，或使用梯度（次梯度）来近似等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>运筹学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分支定界法与分支定价法</title>
    <link href="/2023/01/11/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95%E4%B8%8E%E5%88%86%E6%94%AF%E5%AE%9A%E4%BB%B7%E6%B3%95/"/>
    <url>/2023/01/11/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/%E5%88%86%E6%94%AF%E5%AE%9A%E7%95%8C%E6%B3%95%E4%B8%8E%E5%88%86%E6%94%AF%E5%AE%9A%E4%BB%B7%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>#! https://zhuanlan.zhihu.com/p/598134928 #分支定界法与分支定价法</p><h2 id="分支定界法branch-and-bound">分支定界法（Branch and bound）</h2><p>分支定界法一般用于解决整数线性规划和混合整数线性规划。它本质上是一种基于搜索的算法，是比较暴力的，并且在极坏情况下可能会退化成枚举。</p><p>对于如下混合整数线性规划问题</p><p><span class="math display">\[\min_{x,y} f(x,y) \\    {s.t.}\left \{        \begin{array}{l}            Ax = 0,By=0\\            x\in R^{n_1},y\in Z^{n_2}        \end{array}        \right.\]</span></p><p>其中x是普通变量，y是整数变量。我们把y是整数这个约束松弛掉，就得到松弛后问题</p><p><span class="math display">\[\min_{x,y} f(x,y) \\    {s.t.}\left \{        \begin{array}{l}            Ax = 0,By=0\\            x\in R^{n_1},y\in R^{n_2}        \end{array}        \right.\]</span></p><p>注意，这是一个普通的线性规划问题，我们可以使用单纯形法或者其它线性规划算法解决。但求出来的解<spanclass="math inline">\(y^*\)</span>中很有可能有一些不是整数，导致解不在原问题的可行域中。显然，这个松弛问题的解是原问题的一个下界。接下来开始进行分支限界，取<spanclass="math inline">\(y^*\)</span>中一个不是整数的分量<spanclass="math inline">\(y_j^*\)</span>，构造这样两个分支问题</p><p>第一个分支问题 <span class="math display">\[\min_{x,y} f(x,y) \\    {s.t.}\left \{        \begin{array}{l}            Ax = 0,By=0\\            y_j \ge \lceil y_j^* \rceil \\            x\in R^{n_1},y\in R^{n_2}        \end{array}        \right.\]</span></p><p>第二个分支问题 <span class="math display">\[\min_{x,y} f(x,y) \\    {s.t.}\left \{        \begin{array}{l}            Ax = 0,By=0\\            y_j \le \lfloor y_j^* \rfloor \\            x\in R^{n_1},y\in R^{n_2}        \end{array}        \right.\]</span></p><p>这样我们就有了两个新的节点，接下来只要递归的对这两个节点继续分支限界就可以了，直到获得整数解或无解就停止。如图</p><figure><imgsrc="images/6db197abb33403ac50ec218699ec1636e6f498fade63329a5b6d42d4aa80d332.png"alt="搜索树" /><figcaption aria-hidden="true">搜索树</figcaption></figure><p>这样就构成了一颗搜索树。注意这棵树有这样几个特点</p><ol type="1"><li>由于分支限界是不断进行的，我们一直在添加约束，所以目标函数值一定是在不断增大的，后面的节点目标函数值一定大于前面节点（父节点，祖先节点）的目标函数值</li><li>构成方式是不唯一的，因为每次求解得到的<spanclass="math inline">\(y^*\)</span>中非整数变量可能不止一个，可以选取其中任意一个进行分支限界</li><li>搜索方式是不唯一的，可以使用深度优先搜索（DFS），广度优先搜索（BFS）等多种方式搜索</li></ol><p>在搜索的过程中，还需要注意进行<strong>剪枝</strong>。无论搜索的顺序如何，一旦获得一个可行解，那么它会是解的上界，我们记忆下这个上界。在接下来的搜索过程中，一旦当前的目标函数值超过了上界，就剪掉这棵子树。</p><h2 id="分支定价法branch-and-price">分支定价法（Branch and price）</h2><p>分支定价法其实就是分支定界法+列生成算法。列生成算法的具体描述可以看本专栏之前的文章。</p><p>分支定界法中，求解每个节点对应的松弛问题的时候，是直接求解的。而分支定价法中使用列生成算法来求解。其好处是显然的，列生成算法在变量很多的情况比普通的单纯形法有更好的性能。而且，在解决某个节点的RMP的时候，可以不用重新构建问题，运行一次完整的列生成算法，而是继承父节点的RMP问题，并添加约束，这可能会进一步的加速求解过程。</p>]]></content>
    
    
    
    <tags>
      
      <tag>运筹学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>割平面法（行生成算法）与列生成算法以及它们的对偶性</title>
    <link href="/2023/01/10/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/%E5%89%B2%E5%B9%B3%E9%9D%A2%E6%B3%95%EF%BC%88%E8%A1%8C%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%EF%BC%89%E4%B8%8E%E5%88%97%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%AF%B9%E5%81%B6%E6%80%A7/"/>
    <url>/2023/01/10/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/%E5%89%B2%E5%B9%B3%E9%9D%A2%E6%B3%95%EF%BC%88%E8%A1%8C%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%EF%BC%89%E4%B8%8E%E5%88%97%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%AE%83%E4%BB%AC%E7%9A%84%E5%AF%B9%E5%81%B6%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>#! https://zhuanlan.zhihu.com/p/598065618 #割平面法（行生成算法）与列生成算法以及它们的对偶性</p><p>在线性规划中，我们把变量称为“列”，把约束称为“行”。行生成和列生成算法大思路是一致的，都是由于原问题规模过大，所以需要把原问题“简化”一部分，不过这就导致丢失了部分信息，失去了最优性。因此我们就要以某种方式迭代的把简化掉的部分再添加回去一部分，直到得到最优解。</p><h2 id="割平面法">割平面法</h2><p>割平面法又叫行生成算法。对于一个线性规划问题</p><p><span class="math display">\[\min c^T x \\    {s.t.}            Ax \ge b\]</span></p><p>其中<span class="math inline">\(A\in R^{m\timesn}\)</span>，如果m特别大，也就是约束的数目特别多，我们有时就会考虑使用行生成算法。</p><p>由于m特别大，我们可以猜测绝大多数约束应该是不起作用的，那么我们可以丢掉一些约束，也就是把A丢掉一些行，组成新的系数矩阵<spanclass="math inline">\(\tilde{A}\)</span>，对应的也得到<spanclass="math inline">\(\tilde{b}\)</span>，这样就得到一个简化后的问题</p><p><span class="math display">\[\min c^T x \\    {s.t.}        \begin{array}{l}            \tilde{A}x \ge \tilde{b}        \end{array}\]</span></p><p>由于丢掉了一些约束，这个简化后问题的最优解应该是小于等于原问题最优解的。并且这个解不一定在原问题可行域内。实际上如果这个解在原问题可行域内，说明我们已经求得原问题最优解了，迭代可以结束。而如果不是，那么我们需要在被丢掉的约束中取一些重新加入简化后问题。</p><p>显然，如何选择加入的约束是一个重要的任务，因为加入的约束好就更可能快的求得最优解。一种常用的方式是找到违背程度最大的约束加入原问题，也就是找到</p><p><span class="math display">\[\min_j A_j x^* -b\]</span></p><p>然后把第j个约束加入简化后问题。</p><h2 id="列生成算法">列生成算法</h2><p>对于一个线性规划问题</p><p><span class="math display">\[\min c^T x \\    {s.t.}\left \{        \begin{array}{l}            Ax = b\\            x\ge 0        \end{array}        \right. \ (MP)\]</span></p><p>其中<span class="math inline">\(A\in R^{m\timesn}\)</span>，如果n特别大，也就是变量的数目特别多，那么求解这样一个问题是很困难的。但是从单纯形法中我们知道，绝大多数变量其实是没有用的。其中<spanclass="math inline">\(n-m\)</span>个非基变量都是0。因此这就提示我们可能有某种方式可以简化计算。</p><p>把一部分变量暂时丢掉，也就是强制它们为非基变量，相当于在A中取一些列，组成新的系数矩阵<spanclass="math inline">\(\tilde{A}\)</span>，对应的也得到<spanclass="math inline">\(\tilde{c}\)</span>。这样就得到如下restrict mainproblem（RMP）</p><p><span class="math display">\[\min \tilde{c}^T x \\    {s.t.}\left \{        \begin{array}{l}            \tilde{A}x = b\\            x\ge 0        \end{array}        \right. \ (RMP)\]</span></p><p>考虑RMP和MP的关系，由于RMP是强制MP中一部分变量为0，所以一定有<spanclass="math inline">\(RMP^* \geMP^*\)</span>。接下来考虑将一些变量添加回RMP，来迭代出更优的解。选择的依据就是检验数（reducecost）。</p><p><span class="math display">\[\sigma_j = c_j - c_B^TB^{-1}A_j\]</span></p><p>检验数表示添加该变量后的目标函数单位变化量，因此我们会选择检验数为负且最小的变量添加。考虑计算<spanclass="math inline">\(c_B^TB^{-1}\)</span>并不是一件轻松的事情。直接计算是困难的，因为计算矩阵的逆是一件代价很大的事情。我们可以构造子问题来进行计算。取RMP的对偶问题</p><p><span class="math display">\[\max -b^Tv \\    {s.t.}        \begin{array}{l}            \tilde{A}^Tv+\tilde{c}\ge0 \\        \end{array}\]</span></p><p>利用强对偶理论<spanclass="math inline">\(p^*=d^*\)</span>就能得到<spanclass="math inline">\(v^T =-c_B^TB^{-1}\)</span>。具体推导过程可以看上一篇文章。</p><h2id="列生成算法和行生成算法割平面法的对偶关系">列生成算法和行生成算法（割平面法）的对偶关系</h2><p>列生成算法简化掉了部分变量，导致失去了最优性，得到的是次优的解，在迭代的过程中逐渐加入变量来优化原解；行生成算法丢掉了部分约束，导致得到的解不一定可行，在迭代的过程中逐渐加入约束使解逐渐可行。它们一个是从可行的方向，一个是从不可行的方向来逼近最优解。</p><p>我们知道在对偶问题中，进行对偶变换时约束会变成变量、而变量会到约束中。因此行生成和列生成的过程在直觉上好像存在某种对偶性，我们下面来具体验证这种直觉。</p><p>考虑RMP的对偶问题RD</p><p><span class="math display">\[\max -b^Tv \\    {s.t.}        \begin{array}{l}            \tilde{A}^Tv+\tilde{c}\ge0 \ (RD) \\        \end{array}\]</span></p><p>我们也写出原问题MP的对偶问题D</p><p><span class="math display">\[\max -b^Tv \\    {s.t.}        \begin{array}{l}            A^Tv+c\ge0 \ (D) \\        \end{array}\]</span></p><p>记<span class="math inline">\(d^*\)</span>是RD的最优解，<spanclass="math inline">\(p^*\)</span>是RMP的最优解；<spanclass="math inline">\(d^*\)</span>。如果<spanclass="math inline">\(d^*\)</span>不是D的最优解，这意味着这样几个事实</p><ol type="1"><li><spanclass="math inline">\(p^*\)</span>也不是MP的最优解，所以迭代还要继续。</li><li><spanclass="math inline">\(d^*\)</span>比D的最优解大，因为D的可行域是RD的子集。</li></ol><p>根据事实2，依据行生成算法的思路，这就意味着我们需要找到违背的约束把它添加到RD中。当然，我们希望添加违背程度最严重的约束，也就是找到</p><p><span class="math display">\[\min_j A^T_jd^* + c_j\]</span></p><p>我们知道<span class="math inline">\(v^T =-c_B^TB^{-1}\)</span>，上式的<spanclass="math inline">\(d^*\)</span>实际上就是最优的<spanclass="math inline">\(v\)</span>，带入得子问题为</p><p><span class="math display">\[\min_j  c_j-c_B^TB^{-1}A^T_j\]</span></p><p>不难发现，这和列生成算法中找到最小化检验数的子问题是一模一样的。另一方面，把违背的约束添加到RD中，对偶回RMP也就相当于是添加了一个新的变量。因此，行生成和列生成其实就是对偶的关系。</p>]]></content>
    
    
    
    <tags>
      
      <tag>运筹学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Lagrange对偶到线性规划对偶问题</title>
    <link href="/2023/01/10/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2023/01/10/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/%E5%AF%B9%E5%81%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>#! https://zhuanlan.zhihu.com/p/597492395 #从Lagrange对偶到线性规划对偶问题</p><h2 id="lagrange对偶">Lagrange对偶</h2><p>我们熟悉Lagrange乘子法，它是求解带有等式约束的最值问题的方法，而Lagrange对偶函数可以理解为是它的一种拓展，它能解决带有等式和不等式约束的问题，也就是标准形式的优化问题。标准形式的优化问题形如</p><p><span class="math display">\[\min f_0(x) \\    {s.t.}\left \{        \begin{array}{l}            f_i(x)\le 0,i=1,\dots ,m\\            h_i(x)=0,i=1,\dots ,p        \end{array}        \right.\]</span></p><p>设问题的定义域<span class="math inline">\(D = \cap_{i=0}^m dom \ f_i\cap \cap_{i=1}^p dom \ h_i\)</span>非空，最优值为<spanclass="math inline">\(p^*\)</span>。</p><p>定义Lagrange对偶函数<span class="math inline">\(g:R^m \times R^p\rightarrow R\)</span>，对<span class="math inline">\(\lambda \inR^m\)</span>，<span class="math inline">\(v \in R^p\)</span>有</p><p><span class="math display">\[g(\lambda,v) = \inf_{x\in D} L(x,\lambda,v) = \inf_{x\in D}(f_0(x)+\sum_{i=1}^m \lambda_i f_i(x) + \sum_{i=1}^p v_i h_i(x))\]</span></p><p>如果Lagrange函数关于x无下界，那么对偶函数取值为<spanclass="math inline">\(-\infty\)</span>。无论原问题的凸性如何，Lagrange对偶函数都是凹函数。因为它是一族关于<spanclass="math inline">\(\lambda,v\)</span>的线性函数的逐点下确界。</p><p>对偶函数值构成了原问题最优值的下界，即对于任意的<spanclass="math inline">\(\lambda \ge 0\)</span>和<spanclass="math inline">\(v\)</span>，有</p><p><span class="math display">\[g(\lambda,v) \le p^*\]</span></p><p>证明是显然的。</p><h3 id="lagrange对偶函数与共轭函数">Lagrange对偶函数与共轭函数</h3><p>我们知道<span class="math inline">\(f:R^n \rightarrowR\)</span>的共轭函数<span class="math inline">\(f^*\)</span>为</p><p><span class="math display">\[f^*(y) = \sup_{x\in dom \ f} (y^Tx-f(x))\]</span></p><p>一些情况下利用共轭函数，我们可以简化Lagrange对偶函数。考虑一个优化问题</p><p><span class="math display">\[\min f_0(x) \\    {s.t.}\left \{        \begin{array}{l}            Ax \le b\\            Cx = d        \end{array}        \right.\]</span></p><p>利用<spanclass="math inline">\(f_0\)</span>的共轭函数，我们可以导出它的对偶函数</p><p><span class="math display">\[g(\lambda,v) = \inf_x (f_0(x) + \lambda^T (Ax-b) + v^T (Cx-d))\\= -b^T\lambda - d^Tv + \inf_x (f_0(x) + (A^T\lambda + C^T v)^T x)\\= -b^T\lambda - d^Tv - f_0^* (-A^T\lambda-C^Tv)\]</span></p><h3 id="lagrange对偶问题">Lagrange对偶问题</h3><p>前面提到对偶函数值给出原问题最优值的下界，那么我们希望得到最优的下界，也就是</p><p><span class="math display">\[\max g(\lambda,v) \\    {s.t.}        \begin{array}{l}            \lambda \ge 0        \end{array}\]</span></p><p>这是一个凸优化问题，它的凸性与原问题的凸性无关。</p><h3 id="强对偶性与slater条件">强对偶性与Slater条件</h3><p>如果Lagrange对偶问题的最优解是<spanclass="math inline">\(d^*\)</span>，我们知道一定有<spanclass="math inline">\(d^*\le p^*\)</span>。在一些情况下，有<spanclass="math inline">\(d^*=p^*\)</span>，那么此时强对偶性成立。</p><p>如果原问题是凸的，那么在一些情况下（并不是所有情况）强对偶性会成立。一个简单的约束准则是Slater条件，当原问题是凸的且Slater条件成立，那么强对偶性成立。对于如下形式的凸问题</p><p><span class="math display">\[\min f_0(x) \\    {s.t.}\left \{        \begin{array}{l}            f_i(x)\le 0,i=1,\dots ,m\\            Ax = b        \end{array}        \right.\]</span></p><p>Slater条件说的是存在一点<span class="math inline">\(x\in relint \D\)</span>，也就是D的相对内点，使下式成立</p><p><span class="math display">\[f_i(x) &lt; 0,\quad i=1,\dots,m, \quad Ax=b\]</span></p><p>而在不等式约束<spanclass="math inline">\(f_i\)</span>中，如果其中一些是仿射函数（线性函数）时，Slater条件可以进一步的改进。如果最前面的k个约束<spanclass="math inline">\(f_1,\dots,f_k\)</span>是仿射的，则Slater条件可以改进为存在一点<spanclass="math inline">\(x\in relint \ D\)</span>使得</p><p><span class="math display">\[f_i(x)\le 0, \ i=1,\dots,k, \quad f_i(k)&lt;0, \ i=k+1,\dots,m,\quadAx=b\]</span></p><p>也就是说其中仿射的不等式约束是不需要严格成立的。</p><h2 id="线性规划对偶问题">线性规划对偶问题</h2><p>根据Slater条件，我们不难发现，对于任意的线性规划问题，只要是原问题是可行的，就满足（改进的）Slater条件，也就是强对偶性成立。因此研究线性规划问题的对偶问题是很有价值的。另一方面研究线性规划的对偶问题对我们后续的处理、解释等都是有好处的。</p><h3 id="标准形式线性规划">标准形式线性规划</h3><p>对于标准形式的线性规划，即</p><p><span class="math display">\[\min c^T x \\    {s.t.}\left \{        \begin{array}{l}            Ax = b\\            x\ge 0        \end{array}        \right.\]</span></p><p>它的Lagrange函数为 <span class="math display">\[L(x,\lambda,v) = c^Tx-\lambda^Tx+v^T(Ax-b) = -b^Tv + (c+A^Tv-\lambda)^Tx\]</span></p><p>所以它的Lagrange对偶函数为 <span class="math display">\[g(\lambda,v) = \inf_x L(x,\lambda,v) = -bv^T + \inf_x(c+A^Tv-\lambda)^Tx\]</span></p><p>我们知道非常函数的仿射函数是无界的，因此 <spanclass="math display">\[g(\lambda) = \left \{ \begin{array}{l}            -b^Tv\lambda,A^Tv-\lambda+c=0\\            -\infty,A^Tv-\lambda+c\neq0        \end{array} \right .\]</span></p><p>所以它的对偶问题就为</p><p><span class="math display">\[\max -b^Tv \\    {s.t.}\left \{        \begin{array}{l}            A^Tv-\lambda+c=0\\            \lambda \ge 0        \end{array}        \right.\]</span></p><p>它等价于</p><p><span class="math display">\[\max -b^Tv \\    {s.t.}        \begin{array}{l}            A^Tv+c\ge0\\        \end{array}\]</span></p><h3 id="不等式形式线性规划">不等式形式线性规划</h3><p>不等式形式线性规划即</p><p><span class="math display">\[\min c^T x \\    {s.t.}        \begin{array}{l}            Ax \le b        \end{array}\]</span></p><p>它的Lagrange函数为</p><p><span class="math display">\[L(x,\lambda) = c^T x + \lambda^T(Ax-b) = -b^T \lambda + (A^T \lambda +c)^T x\]</span></p><p>所以它的Lagrange对偶函数为</p><p><span class="math display">\[g(\lambda) = \inf_x L(x,\lambda) = -b^T \lambda + \inf_x (A^T \lambda +c)x\]</span></p><p>我们知道，对于一个仿射函数，如果不是常函数，那么它是无界的，因此</p><p><span class="math display">\[g(\lambda) = \left \{ \begin{array}{l}            -b^T\lambda,A^T\lambda+c=0\\            -\infty,A^T\lambda+c\neq0        \end{array} \right .\]</span></p><p>所以它的对偶问题就为</p><p><span class="math display">\[\max -b^T \lambda \\    {s.t.}\left \{        \begin{array}{l}            A^T\lambda+c=0\\            \lambda \ge 0        \end{array}        \right.\]</span></p><p>可以看到，标准形式线性规划的对偶问题是只含有不等式约束的线性规划，只含有不等式约束的线性规划的对偶问题是标准形式的线性规划。</p><h3 id="一般形式的线性规划">一般形式的线性规划</h3><p>对于一般形式的线性规划，也就是</p><p><span class="math display">\[\min c^T x + d \\    {s.t.}\left \{        \begin{array}{l}            Gx \le h\\            Ax = b        \end{array}        \right.\]</span></p><p>它的Lagrange函数为 <span class="math display">\[L(x,\lambda,v) = c^Tx + d + \lambda^T(Gx-h)+v^T(Ax-b) = -b^Tv-h^T\lambda+d + (c+A^Tv+G^T\lambda)^Tx\]</span></p><p>所以它的Lagrange对偶函数为 <span class="math display">\[g(\lambda,v) = \inf_x L(x,\lambda,v) = -b^Tv -h^T\lambda+d + \inf_x(c+A^Tv+G^T\lambda)^Tx\]</span></p><p>利用仿射函数的性质，得 <span class="math display">\[g(\lambda) = \left \{ \begin{array}{l}            -b^Tv -h^T\lambda+d ,c+A^Tv+G^T\lambda=0\\            -\infty,c+A^Tv+G^T\lambda\neq0        \end{array} \right .\]</span></p><p>所以它的对偶问题为</p><p><span class="math display">\[\max -b^Tv -h^T\lambda+d \\    {s.t.}\left \{        \begin{array}{l}            c+A^Tv+G^T\lambda=0\\            \lambda \ge 0        \end{array}        \right.\]</span></p><p>观察它的特点，原问题中x的项都失去x并出现在了约束中，而原问题中的不含x的项则出现在了目标函数中。实际上，网上有很多关于利用原问题直接写出对偶问题的记忆法，这里不再赘述。</p>]]></content>
    
    
    
    <tags>
      
      <tag>运筹学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性规划对偶问题、影子价格（shadow price）与单纯形法检验数（reduce cost）</title>
    <link href="/2023/01/10/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/%E5%BD%B1%E5%AD%90%E4%BB%B7%E6%A0%BC%E4%B8%8E%E5%88%86%E6%94%AF%E5%AE%9A%E4%BB%B7%E6%B3%95/"/>
    <url>/2023/01/10/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/%E5%BD%B1%E5%AD%90%E4%BB%B7%E6%A0%BC%E4%B8%8E%E5%88%86%E6%94%AF%E5%AE%9A%E4%BB%B7%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>#! https://zhuanlan.zhihu.com/p/597955786 #线性规划对偶问题、影子价格（shadow price）与单纯形法检验数（reducecost）</p><p>Lagrange对偶问题（包括线性规划对偶问题）实际上可以有一个经济学的解释（关于Lagrange对偶、线性规划对偶的数学推导可以看上一篇文章）。对于这样一个原问题</p><p><span class="math display">\[\min f_0(x) \\    {s.t.}        \begin{array}{l}            f_i(x) \le 0,i=1,\dots,m        \end{array}\]</span></p><p>可以把x理解为公式的某种经营策略，那么<spanclass="math inline">\(f_0(x)\)</span>表示这种经营策略下的成本。而<spanclass="math inline">\(f_i(x)\le0\)</span>表示某种限制，比如公司的劳动力上限，仓库容量上限等等。那么这个优化问题就是找到最好的经营策略，它的成本最小。或者说利润最高。</p><p>接下来考虑另一种情况，约束是可以被违背的，但是对违背的部分有一些惩罚，或者说额外成本，与违背的部分成线性关系。即约束i被违背的部分<spanclass="math inline">\(f_i(x)\)</span>带来的成本为<spanclass="math inline">\(\lambda_if_i(x)\)</span>。相应的，如果约束不是紧的，公式会因此得到收益。即当<spanclass="math inline">\(f_i(x)&lt;0\)</span>，带来的成本是个负数（也就是获得收益）。系数<spanclass="math inline">\(\lambda_i\)</span>的含义是违背<spanclass="math inline">\(f_i\)</span>的价格。</p><p>在这种情况下，以x的方式运营，约束价格为<spanclass="math inline">\(\lambda\)</span>，公司的总成本就为<spanclass="math inline">\(L(x,\lambda)=f_0(x)+\sum_{i=1}^m \lambda_if_i(x)\)</span>，这就是Lagrange函数。公式当然会选择最好的经营策略，使得成本最小，也就是<spanclass="math inline">\(g(\lambda) = \inf_xL(x,\lambda)\)</span>，这就是Lagrange对偶函数。同时基于这种解释，也很好理解<spanclass="math inline">\(d^*\lep^*\)</span>，因为在这个情况下公式实际上有了更多的选择，出售多余的约束，而购入需要的约束。</p><p>现在假设强对偶性成立（比如线性规划的情形），对偶问题的最优解<spanclass="math inline">\(\lambda^*\)</span>可以看作这样的价格：在这个价格下，允许以这样的价格支付被违背的约束（或是通过不紧的约束获得收益）相比约束不能被违背时没有任何优势。实际上<spanclass="math inline">\(\lambda^*\)</span>就是原问题的<strong>影子价格</strong>。</p><p>影子价格的通常定义表述为：当限制条件放宽一个单位之后，最适解决方案的真实价值的变化。可以看到这个定义和我们前面的描述是相容的。它反映了最优情况下资源的边际价值。</p><h2 id="单纯形法检验数">单纯形法检验数</h2><p>在线性规划中，其实影子价格还与单纯形法的检验数有密切的联系。</p><h3 id="单纯形算法角度">单纯形算法角度</h3><p>回忆一下单纯形法的步骤，根据线性规划基本定理，线性规划的最优解一定在顶点出现。而单纯形法给出了一个好的寻找最优顶点的算法，具体地，它是一种基于迭代的算法，每次根据检验数来选择一个入基出基变量。下面我们来具体描述一下关于检验数的部分。</p><p>对于这样一个标准形式的线性规划</p><p><span class="math display">\[\min c^T x \\    {s.t.}\left \{        \begin{array}{l}            Ax = b\\            x\ge 0        \end{array}        \right.\]</span></p><p>我们把变量x拆分成基变量和非基变量（等于0的变量）</p><p><span class="math display">\[x=\left[\begin{array}{l}x_B \\x_N\end{array}\right]\]</span></p><p>其中<span class="math inline">\(x_B \in R^m\)</span>是基变量，<spanclass="math inline">\(x_N \in R^{(n-m)}\)</span>是非基变量。</p><p>那么原问题就可以写成</p><p><span class="math display">\[\min c_B^T x_B + c^T_Nx_N \\    {s.t.}\left \{        \begin{array}{l}            Bx_B + Nx_N = b\\            x_B\ge 0,x_N\ge 0        \end{array}        \right.\]</span></p><p>根据约束我们有</p><p><span class="math display">\[x_B = B^{-1}b-B^{-1}Nx_N\]</span></p><p>注意这里取B的逆是不会出问题的，因为B是满秩的。我们要找到一个新解<spanclass="math inline">\(x&#39;\)</span></p><p><span class="math display">\[x&#39; = x + \theta d\]</span></p><p>由于<span class="math inline">\(x&#39;\)</span>应该是<spanclass="math inline">\(x\)</span>的相邻顶点，所以我们实际上是在非集变量中找到一个入基变量<spanclass="math inline">\(x_j\)</span>，那么<spanclass="math inline">\(d\)</span>中与非基变量对应的除了<spanclass="math inline">\(d_j\neq 0\)</span>外，其它分量都为0。</p><p>又因为新解<spanclass="math inline">\(x&#39;\)</span>也应当满足约束，所以有<spanclass="math inline">\(A(x+\thetad)=b\)</span>，我们知道x是可行解，所以<spanclass="math inline">\(Ax=b\)</span>，那么<spanclass="math inline">\(Ad=0\)</span>，因此</p><p><span class="math display">\[0 = Ad = Bd_B + A_j\]</span></p><p>所以可以导出基可行方向为</p><p><span class="math display">\[d_B = -B^{-1}A_j\]</span></p><p>沿着这个可行方向，我们可以算出目标函数的变化量，通常情况下是减少量（因为我们会去可以选择使目标函数减少的入基变量）</p><p><span class="math display">\[\Delta = c^Td = c^Td_B + c_j = c_j - c_B^TB^{-1}A_j\]</span></p><p>这个数在单纯形法中也被成为检验数。它实际上表示沿着某个可行方向，移动一个单位时目标函数的减少量。</p><h3 id="对偶问题与影子价格角度">对偶问题与影子价格角度</h3><p>对于原问题，我们熟知它的对偶问题为</p><p><span class="math display">\[\max -b^Tv \\    {s.t.}        \begin{array}{l}            A^Tv+c\ge0\\        \end{array}\]</span></p><p>当我们给原问题约束右侧的<spanclass="math inline">\(b\)</span>做出一点调整，调整为<spanclass="math inline">\(b+d\)</span>时。由于非退化情况下原问题满足<spanclass="math inline">\(x_B =B^{-1}b&gt;0\)</span>，由于调整是可以很细微的，所以我们可以找到<spanclass="math inline">\(B(b+d)&gt;0\)</span>。</p><p>由强对偶理论我们知道调整后也有<span class="math inline">\(p^* =d^*\)</span>，也就是</p><p><span class="math display">\[c_B^T B^{-1} (b+d) = -v^T(b+d)\]</span></p><p>得到对偶问题的最优解<span class="math inline">\(v^T =-c_B^TB^{-1}\)</span>。</p><p>注意到检验数中也出现了这个结构。它们都是考察作出某种单位变化后对目标函数的影相值，而入基出基操作在某种程度上也可以和调整<spanclass="math inline">\(b\)</span>联系起来。</p><p>另外，这也给出了一种求解单纯形法检验数的方法--我们可以通过求解对偶问题来间接的求解单纯形法检验数。在规模很大的时候求解<spanclass="math inline">\(B\)</span>的逆并不是一件容易的事情，而求解对偶问题可能更简单一些。我们将在讲解列生成算法的时候更深入的分析这个问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>运筹学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>共轭函数（Legendre变换与Fenchel变换）</title>
    <link href="/2023/01/08/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/%E5%85%B1%E8%BD%AD%E5%87%BD%E6%95%B0/"/>
    <url>/2023/01/08/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/%E5%85%B1%E8%BD%AD%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>#! https://zhuanlan.zhihu.com/p/597399183 #共轭函数（Legendre变换与Fenchel变换）</p><p>Legendre变换是物理（力学，热力学），数学中常用的一种变换。它把可微凸函数从关于原自变量x的函数变为关于点导数（梯度）的函数。也就是如果记<spanclass="math inline">\(k=\dfrac{df}{dx}\)</span>，那么把原函数<spanclass="math inline">\((x,f(x))\)</span>变换为<spanclass="math inline">\((k,f^*(k))\)</span>。</p><p>但是Legendre变换要求函数可微，Fenchel变换可以理解为对Legendre变换的推广，作用类似而不需要函数是可微的。</p><h2 id="legendre变换勒让德变换">Legendre变换（勒让德变换）</h2><p>取原函数<spanclass="math inline">\(f(x)\)</span>，我们现在来导出它的Legendre共轭函数<spanclass="math inline">\(f^*(x)\)</span>。这里的<spanclass="math inline">\(x\in R^n\)</span>。</p><p>设<span class="math inline">\(u(x) = \nablaf(x)\)</span>。那么考虑<spanclass="math inline">\(f(x)\)</span>的全微分形式， <spanclass="math display">\[df(x) = dx\nabla f(x) = dxu(x)\]</span></p><p>注意到<span class="math inline">\(d(u^T(x)x ) = d(x)u(x) +d(u(x))x\)</span>，即</p><p><span class="math display">\[dxu(x) = d(u^T(x)x ) - d(u(x))x\]</span></p><p>带入上式就得到</p><p><span class="math display">\[x d(u(x)) = d ( u^T(x)x - f(x) )\]</span></p><p>记<span class="math inline">\(g(u) = u^Tx - f(x)\)</span>，那么<spanclass="math inline">\(dg(u) = du \nabla g(u)\)</span>，因为<spanclass="math inline">\(du\nabla g(u) = d(u) x\)</span>，这就得到<spanclass="math inline">\(x = \nabla g(u)\)</span>。</p><p>我们发现此时<span class="math inline">\(u(x) = \nablaf(x)\)</span>，<span class="math inline">\(x = \nablag(u)\)</span>。因此这个<spanclass="math inline">\(g\)</span>实际上就是我们所求的<spanclass="math inline">\(f^*\)</span>。</p><p>我们得到<span class="math inline">\(f^*(u) = u^Tx -f(x)\)</span>。</p><p>考虑它的几何意义，当<span class="math inline">\(x\inR\)</span>，设它在x处的斜率为<spanclass="math inline">\(k(x)\)</span>，那么<spanclass="math inline">\(f^*(k) = kx-f(x)\)</span>。其值为<spanclass="math inline">\(f(x)\)</span>在x处切线在y轴上的截距。所以几何意义上，<spanclass="math inline">\(f^*\)</span>是在用一族切线来描述原曲线，把切线的斜率作为自变量，而截距作为因变量。</p><h2 id="fenchel变换">Fenchel变换</h2><p>现在我们正式的给出共轭函数的定义，对于函数<spanclass="math inline">\(f:R^n \rightarrow R\)</span>，定义函数<spanclass="math inline">\(f^* : R^n \rightarrow R\)</span>为</p><p><span class="math display">\[f^*(y) = \sup_{x\in dom \ f} (y^Tx-f(x))\]</span></p><p>它具有这样一些性质</p><h3 id="与legendre变换的相容性">与Legendre变换的相容性</h3><p>在f是凸的，且可微的情况下，Legendre变换与Fenchel变换是等价的。</p><p>证明并不困难。由于f是凸且可微的，<span class="math inline">\(h(x) =y^Tx-f(x)\)</span>是凹的，因此它的最值点一定是梯度为0的点。</p><p>这一点满足<span class="math inline">\(\nablah(x_0)=0\)</span>，即<span class="math inline">\(\nabla f(x_0) =y\)</span>。那么<span class="math inline">\(f^*(y) = \nabla f^T(x_0)x_0- f(x_0)\)</span>。这与Legendre变换是相容的。</p><h3 id="fenchel不等式">Fenchel不等式</h3><p>由定义，有</p><p><span class="math display">\[f(x) + f^*(x) \ge x^Ty\]</span></p><h3 id="共轭的共轭">共轭的共轭</h3><p>“共轭”这个名称似乎暗示了共轭的共轭就是原函数，在Legendre变换的推导中也能看见这一点。实际上，如果f是凸函数且f是闭的，那么<spanclass="math inline">\(f^{**}=f\)</span>。下面进行证明</p><p>取<span class="math inline">\(f^*(y) = \sup_x (y^Tx-f(x)) = \nablaf^T(x_0)x_0 - f(x_0)\)</span>，那么</p><p><span class="math display">\[f^{**}(x) = \sup_y (x^Ty-f^*(y))\\= \sup_y (x^Ty-(\nabla f^T(x_0)x_0 - f(x_0)))\\= \sup_y (\nabla f^T(x_0)(x-x_0) + f(x_0))\\= \sup_{x_0} (f(x_0) + \nabla f^T(x_0)(x-x_0))\]</span></p><p>由凸函数的性质，<span class="math inline">\(\sup_{x_0} (f(x_0) +\nabla f^T(x_0)(x-x_0)) = f(x)\)</span>，这就证明了原结论。</p><h3 id="独立函数的和">独立函数的和</h3><p>如果<span class="math inline">\(f(u,v) = f_1(u) +f_2(v)\)</span>，其中<span class="math inline">\(f_1\)</span>和<spanclass="math inline">\(f_2\)</span>是凸函数，共轭函数为<spanclass="math inline">\(f_1^*\)</span>和<spanclass="math inline">\(f_2^*\)</span>，那么</p><p><span class="math display">\[f^*(w,z) = f_1^*(w)+f_2^*(z)\]</span></p><h3 id="仿射变换">仿射变换</h3><p>对<span class="math inline">\(g(x)=af(x)+b\)</span>有</p><p><span class="math display">\[g^*(y) = af^*(y/a)-b\]</span></p><p>对<span class="math inline">\(g(x) = f(Ax+b)\)</span>有</p><p><span class="math display">\[g^*(y) = f^*(A^{-T}y) - b^TA^{-T}y\]</span></p>]]></content>
    
    
    
    <tags>
      
      <tag>运筹学</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两种TSP问题（旅行推销员问题）的复杂性证明</title>
    <link href="/2023/01/02/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/tsp%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/01/02/%E6%9D%A5%E8%87%AA%E7%9F%A5%E4%B9%8E/tsp%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>#! https://zhuanlan.zhihu.com/p/596106342 #两种TSP问题（旅行推销员问题）的复杂性证明</p><p>我们平时说的TSP问题实际上有两种，一种是原始版本，我们称之为tour-TSP。它要求从某个点出发，经过每个点一次，然后再回到原点。另一种是变种path-TSP，它使得可以从任意点出发，并且经过每个点一次，最终不需要回到原点。实际上可以证明这两个问题有相似的复杂性。</p><h3 id="两种tsp问题的同复杂性">两种TSP问题的同复杂性</h3><p>我们首先来证明tour-TSP是可以线性时间reduce到path-TSP的。</p><p>对于一个tour-TSP的实例，有n个城市<span class="math inline">\(c_1,c_2\cdots,c_n\)</span>。取k为n乘城市间的最大距离。d为距离函数（给出了任意两个城市间的距离）。取一个<spanclass="math inline">\(c_1\)</span>的复制<spanclass="math inline">\(c_1&#39;\)</span>，然后构造如下新的距离函数<spanclass="math inline">\(d&#39;\)</span></p><p><span class="math display">\[d&#39;(c_i,c_j) = d(c_i,c_j) \quad if \ i,j\neq 1\\d&#39;(c_1,c_j) = d(c_1,c_j) + 2k \quad for \ all \ j \\d&#39;(c_1&#39;,c_j) = d(c_1,c_j) + 2k \quad for \ all \ j \\d&#39;(c_1,c_1&#39;) = 3k \\\]</span></p><p>注意到我们可以证明对于<spanclass="math inline">\(d&#39;\)</span>的path-TSP问题，它的最优路径端点一定是<spanclass="math inline">\(\{ c_1,c_1&#39; \}\)</span>。</p><p>反证的假设端点是<span class="math inline">\(\{ c_i,c_j \} \neq \{c_1,c_1&#39; \}\)</span>。如果其中一个<spanclass="math inline">\(c_i,c_j\)</span>是<spanclass="math inline">\(c_1\)</span>或<spanclass="math inline">\(c_1&#39;\)</span>，那么可以证明整条路径最短长度为6k。因为作为端点的<spanclass="math inline">\(c_1\)</span>或<spanclass="math inline">\(c_1&#39;\)</span>至少2k，而作为非端点的<spanclass="math inline">\(c_1\)</span>或<spanclass="math inline">\(c_1&#39;\)</span>至少带来4k的长度。如果<spanclass="math inline">\(c_i,c_j\)</span>都不是<spanclass="math inline">\(c_1\)</span>或<spanclass="math inline">\(c_1&#39;\)</span>，那么路径长度至少为7k，因为此时<spanclass="math inline">\(c_1\)</span>和<spanclass="math inline">\(c_1&#39;\)</span>都是非端点，结论是平凡的。</p><p>但是注意到端点是<span class="math inline">\(\{ c_1,c_1&#39;\}\)</span>的情况，路径长度不会超过5k。因此我们就证明了这个结论。那么就有总路径长度<spanclass="math inline">\(d&#39;(p) = d(t) +4k\)</span>。解决这个path-TSP问题就解决了原tour-TSP问题。</p><h3 id="tour-tsp的np完全性">tour-TSP的NP完全性</h3><p>我们通过把哈密顿回路问题reduce到tour-TSP来证明它的NP完全性。</p><p>哈密顿回路问题是指给定一个图<spanclass="math inline">\(G=(V,E)\)</span>，问G是否包含一条哈密顿回路，即一条通过且只通过每个顶点一次的回路。</p><p>对于一个哈密顿回路问题的实例，构造一个tour-TSP的实例。取城市的集合<spanclass="math inline">\(C=V\)</span>，<spanclass="math inline">\(n=|C|\)</span>，对于任意的两个城市<spanclass="math inline">\(v_i,v_j \in C\)</span>，如果<spanclass="math inline">\((v_i,v_j)\in E\)</span>，则取<spanclass="math inline">\(d(v_i,v_j)=1\)</span>，否则取<spanclass="math inline">\(d(v_i,v_j)=2\)</span>。</p><p>容易发现，如果TSP的结果为n，则哈密顿回路存在；如果TSP的结果大于n，则哈密顿回路不存在。这就解决了原问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>运筹学</tag>
      
      <tag>计算复杂性理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>求次短路</title>
    <link href="/2018/10/25/%E5%9B%BE%E8%AE%BA/%E6%B1%82%E6%AC%A1%E7%9F%AD%E8%B7%AF/"/>
    <url>/2018/10/25/%E5%9B%BE%E8%AE%BA/%E6%B1%82%E6%AC%A1%E7%9F%AD%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="求次短路">求次短路</h1><p>很好想，在spfa的基础上添加一个数组即可，就是转移的时候要注意。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>d[i]=inf;d2[i]=inf;<br>&#125;<br>d[u] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(u);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>inque[x]=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g[x].<span class="hljs-built_in">size</span>();i++)&#123;<br>edge son=g[x][i];<br><span class="hljs-keyword">if</span>(d[x]+son.w&lt;d2[son.v])&#123;<br><span class="hljs-keyword">if</span>(d[x]+son.w==d2[son.v])<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(d[x]+son.w&lt;d[son.v])&#123;<br>    d2[son.v] = d[son.v];<br>    d[son.v] = d[x]+son.w;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[x]+son.w&gt;=d[son.v])d2[son.v] = d[x]+son.w;<span class="hljs-comment">//有问题！</span><br>    <span class="hljs-keyword">if</span>(!inque[son.v])&#123;<br>    q.<span class="hljs-built_in">push</span>(son.v);<br>    inque[son.v]=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这份代码是有问题的，注意这几一句。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(d[x]+son.w&lt;d2[son.v])<br>    <span class="hljs-keyword">if</span>(d[x]+son.w&lt;d[son.v])<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[x]+son.w&gt;=d[son.v])<br></code></pre></td></tr></table></figure><p>我们考虑了这几种情况</p><ol type="1"><li>x的d可以更新son的d2</li><li>x的d可以更新son的d</li><li>x的d2可以更新son的d不用考虑，因为此时用x的d更新肯定更优。</li></ol><p>但是明细我们考虑掉了x的d2可以更新son的d2的情况。</p><p>这种情况是不能省略的。</p><p>的确，用x的d更新son的d2也一定更优，但是x的d可能不能更新son的d2，即这就是最短路，根据题目要求，它是不能作为次短路的。</p><p>所以这种情况必须考虑。</p><p>加上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(d2[x]+son.w&lt;d2[son.v]) d2[son.v] = d2[x]+son.w;<br></code></pre></td></tr></table></figure><p>即可。</p><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=INT_MAX/<span class="hljs-number">2</span>;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br><span class="hljs-type">int</span> v,w;<br><span class="hljs-built_in">edge</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>)&#123;<br>v=a;w=b;<br>&#125;<br>&#125;;<br><br>vector &lt;edge&gt; g[maxn];<br><span class="hljs-type">int</span> inque[maxn];<br><span class="hljs-type">int</span> d[maxn];<br><span class="hljs-type">int</span> d2[maxn];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,y,c;<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>d[i]=inf;d2[i]=inf;<br>&#125;<br>d[u] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>(u);<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br><span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();q.<span class="hljs-built_in">pop</span>();<br>inque[x]=<span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g[x].<span class="hljs-built_in">size</span>();i++)&#123;<br>edge son=g[x][i];<br><span class="hljs-keyword">if</span>(d[x]+son.w&lt;d2[son.v])&#123;<br><span class="hljs-keyword">if</span>(d[x]+son.w==d2[son.v])<span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span>(d[x]+son.w&lt;d[son.v])&#123;<br>    d2[son.v] = d[son.v];<br>    d[son.v] = d[x]+son.w;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d[x]+son.w&gt;d[son.v])d2[son.v] = d[x]+son.w;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(d2[x]+son.w&lt;d2[son.v]) d2[son.v] = d2[x]+son.w;<br>    <span class="hljs-keyword">if</span>(!inque[son.v])&#123;<br>    q.<span class="hljs-built_in">push</span>(son.v);<br>    inque[son.v]=<span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;c);<br>g[x].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(y,c));<br>g[y].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(x,c));<br>&#125;<br><span class="hljs-built_in">spfa</span>(<span class="hljs-number">1</span>);<br>cout&lt;&lt;d2[n];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>USACO题目</title>
    <link href="/2018/10/23/%E9%A2%98%E7%9B%AE/USACO%E9%A2%98%E7%9B%AE/"/>
    <url>/2018/10/23/%E9%A2%98%E7%9B%AE/USACO%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="t1贪婪地送礼者">T1：贪婪地送礼者</h2><p>枚举每个人，把钱送出去就好了，然后统计答案即可。</p><h2 id="t2-usaco1.1黑色星期五friday-the-thirteenth">T2：[USACO1.1]黑色星期五Friday the Thirteenth</h2><blockquote><p>13号又是一个星期五。13号在星期五比在其他日子少吗?为了回答这个问题,写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出N年的一个周期，要求计算1900年1月1日至1900+N-1年12月31日中十三号落在周一到周日的次数，N为正整数且不大于400.</p><p>这里有一些你要知道的:</p><p>1、1900年1月1日是星期一.</p><p>...</p></blockquote><p>此题直接模拟即可。</p><p>需要注意的是对世纪年的特判。包括对当年和以后年（比朴素计算方法少一个闰年）的处理。</p><h2 id="t3坏掉的项链">T3：坏掉的项链</h2><blockquote><p>假如你要在一些点打破项链,展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事(颜色可能与在这之前收集的不同)。确定应该在哪里打破项链来收集到最大数目的珠子</p><p>白色可以当做红色或蓝色。</p></blockquote><p>注意答案永远不能大于珠子总数的边界条件。</p><p>注意从断开出就是白色的特殊情况。</p><h2 id="t4命名那个数字">T4:命名那个数字</h2><p>注意深搜的边界条件。</p><h2 id="t5挤牛奶">T5:挤牛奶</h2><p>差分即可。注意区间的开闭。</p><h2 id="t6方块转换">T6:方块转换</h2><p>模拟。</p><h2 id="t7回文平方数">T7:回文平方数</h2><p>注意输出格式。</p><p>注意转换到高进制要引入字母。</p><p>知识点：进制转换，检验回文数。</p><h2 id="t8双重回文数">T8:双重回文数</h2><p>同上题。</p><h2 id="t9等差数列">T9:等差数列</h2><p>对于一个等差数列，只要枚举前两项，后面的项直接检验即可。</p><p>注意剪枝，如果按照当前的d到第n项大小一定爆了就直接break。</p><h2 id="t10母亲的牛奶">T10:母亲的牛奶</h2><p>注意数据范围，直接搜索即可。</p><p>为了防止死循环，加入判重即可。</p><h2 id="t11数字三角形">T11:数字三角形</h2><p>dp入门题。</p><h2 id="t12回文质数">T12:回文质数</h2><p>枚举即可。</p><h2 id="t13特殊的质数肋骨">T13:特殊的质数肋骨</h2><p>知识点:质数筛。</p><p>注意剪枝，不用枚举每个数。</p><h2 id="t14顺序的分数">T14:顺序的分数</h2><blockquote><p>输入一个自然数N,对于一个最简分数a/b（分子和分母互质的分数）,满足1&lt;=b&lt;=N,0&lt;=a/b&lt;=1,请找出所有满足条件的分数。</p><p>这有一个例子，当N=5时，所有解为：</p><p>0/1 1/5 1/4 1/3 2/5 1/2 3/5 2/3 3/4 4/5 1/1</p><p>给定一个自然数N，1&lt;=n&lt;=160，请编程按分数值递增的顺序输出所有解。</p><p>注：①0和任意自然数的最大公约数就是那个自然数②互质指最大公约数等于1的两个自然数。</p></blockquote><p>这里提供三个思路</p><ol type="1"><li><p>使用gcd判断是否互质，直接枚举即可。</p></li><li><p>使用map记录分数值，依次判断前面是否枚举过。可以证明的是所有可以约分的分数的分数值前面必然已经枚举过了。（注意数组大小要开够）</p></li><li><p>数学方法。（法雷数列） <span class="math display">\[不妨设最简真分数\frac{a}{b}&lt;\frac{c}{d}\\令 m=a+c, n=b+d.可以证明的是\frac{a}{b}&lt;\frac{m}{n}&lt;\frac{c}{d}.\\且\frac{m}{n}是个最简分数.\\对于不等式的证明，考虑使用做差.\\\frac{a+c}{b+d}-\frac{a}{b}=\frac{ab+bc-ab-ad}{b(b+d)}=\frac{bc-ad}{b(b+d)}\\由十字相乘式,由\frac{a}{b}&lt;\frac{c}{d}可导出ad&lt;cb.\\因而\frac{a+c}{b+d}&gt;\frac{a}{b}\\同理可证\frac{a+b}{b+d}&lt;\frac{c}{d}\\对于\frac{m}{n}是最简分数的证明我们考虑使用反证法.\\假设\frac{a+c}{b+d}不是最简分数，则必然可以构造.\\\frac{x(a_0+c_0)}{y(b_0+d_0)}其中x=gcd(a,c),y=gcd(b,d)\\且\gcd(x,y)\neq1\\将式子展开\frac{x*a_0+x*b_0}{y*c_0+y*d_0}\\有a=x*a0,c=y*c_0\\易得\gcd(x*a_0,y*a_0) \neq 1\\但是\gcd(a,b)=1\\矛盾，假设不成立，得证。\]</span></p></li></ol><h2 id="t15三值的排序">T15:三值的排序</h2><blockquote><p>排序是一种很频繁的计算任务。现在考虑最多只有三值的排序问题。一个实际的例子是，当我们给某项竞赛的优胜者按金银铜牌排序的时候。在这个任务中可能的值只有三种1，2和3。我们用交换的方法把他排成升序的。</p><p>写一个程序计算出，给定的一个1,2,3组成的数字序列，排成升序所需的最少交换次数</p><p>1 &lt;= N &lt;= 1000</p></blockquote><p>爆搜肯定是不行了。</p><p>考虑计算排序交换次数的<strong>通用思路</strong>，即把当前序列与排好的序列比较。</p><p>朴素想法，考虑所有情况。</p><ol type="1"><li>一个数字1跑到了区间2，同时区间2中的一个数字2跑到了区间1</li><li>一个数字1跑到了区间3，同时区间3中的一个数字3跑到了区间1</li><li>一个数字2跑到了区间3，同时区间3中的一个数字3跑到了区间2</li><li>一个数字1跑到了区间2，同时区间2中的一个数字2跑到了区间3，区间3中的一个数字3跑到了区间1</li><li>一个数字1跑到了区间3，同时区间3中的一个数字3跑到了区间2，区间2中的一个数字2跑到了区间1</li></ol><p>对于情况1,2,3明显是最优方法，只需要交换一次就可以解决两个数字。</p><p>而情况4,5复杂一些，需要用两次交换解决3个数字。</p><p>于是我们可以贪心的找前三种情况，然后计算还没有归位的数字的数量，乘以2/3即可。</p><p>考虑一下简化方案。记目标区间中都是1的部分为区间A，都是2的部分为区间B，都是3的部分为区间3。</p><p>我们只用考虑两个区间即可。因为如果这两个区间被安排好了，剩下一个区间自然就对了。我们这里考虑A,B两个区间。</p><p>对于A,B两个区间中，所有的3都是要换进区间C中的，这是一个铁逻辑，所以此时的每一次交换都是一次有效且必要的交换。</p><p>考虑区间A。如果是1则可以不管，如果是2则和区间B中的1交换。</p><p>此时应该意识到有两种情况，即区间A中的2和区间B中的1哪个多。</p><p>应该想到的是，在我们把区间C安排好时，区间AB中就只有1和2了。</p><p>之前我们在处理C区间时，策略应当是尽量把1换到A区间，2换到B区间，现在我们考虑这三种情况。</p><ol type="1"><li>刚好，所有的</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NOIP2012 开车旅行</title>
    <link href="/2018/10/20/%E9%A2%98%E7%9B%AE/NOIP2012%E5%BC%80%E8%BD%A6%E6%97%85%E8%A1%8C/"/>
    <url>/2018/10/20/%E9%A2%98%E7%9B%AE/NOIP2012%E5%BC%80%E8%BD%A6%E6%97%85%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p>拿到这道题应该很容易想到排序。关键是如何处理排序之后原序中只能往右走这个信息。</p><p>考虑这样做，在排序好的数组中，离一个点i最近和次进的一定在i-1,i-2,i+1,i+2中。只用处理这四个即可。问题是如何使序合法。</p><p>有一种优雅的解法是在排好序的数组中找到<strong>原序</strong>为1的点，处理好离他最近和次近的点。这样处理出的一定是合法的，因为数组中不存在比它还左的点。处理完后删掉这个点，这样第二个点就变成数组中最左的点了，对他处理出的解也一定是合法的。</p><p>关于删掉点这个操作可以用双向链表来实现。</p><p>考虑到元素没有重复的，也可以用set来实现。</p><p>注意边界问题。（对于set，begin是在set中的，end是不在的，stl中很多区间都是左闭右开的）</p><p>预处理完成后，我们现在已知任意一个点当A或B行驶时唯一会去的地方。这构成两条链。</p><p>容易想到的一种简化方法是找循环节。我们可以把A行驶一次+B行驶一次打包成一个整体。</p><p>想到这一步就已经可以开始打暴力了。需要注意的一个细节是在AB整体不能走后还要判断一次A能不能走。</p><p>考虑怎么进行优化。由于是多次询问，我们浪费的时间主要在处理多次询问上，许多点的搜索是进行了多次的。类似求lca，应该想到可以用倍增来维护，大大降低时间复杂度。</p><p>注意，倍增的基本单位是AB整体。</p><p>初始化时定义以下倍增数组：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)f[i][<span class="hljs-number">0</span>] = aa[bb[i]]; <span class="hljs-comment">//f[i][j]表示从点i走2^j个循环节到的点</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">if</span>(bb[i])b[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">abs</span>(h[bb[i]]-h[i]);<span class="hljs-comment">//b[i][j]表示b从点i走2^j个循环节走的路程</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">if</span>(aa[i])a[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">abs</span>(h[bb[i]]-h[aa[bb[i]]]);<span class="hljs-comment">//a[i][j]表示a从点i走2^j个循环节走的路程</span><br></code></pre></td></tr></table></figure><p>转移方程如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">19</span>;j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>f[i][j] = f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>a[i][j] = a[i][j<span class="hljs-number">-1</span>] + a[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>b[i][j] = b[i][j<span class="hljs-number">-1</span>] + b[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">100005</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br><span class="hljs-type">int</span> h,id;<br><span class="hljs-built_in">node</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>)&#123;<br>id = a;h = b;<br>&#125;<br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-type">const</span> node x) <span class="hljs-type">const</span>&#123;<br>    <span class="hljs-keyword">return</span> h&lt;x.h;<br>&#125;<br>&#125;;<br><br>set&lt;node&gt; s;<br>set&lt;node&gt; ::iterator iter;<br>node city[maxn];<br><span class="hljs-type">int</span> jl1,jl2;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> h[maxn];<br><span class="hljs-type">int</span> a[maxn][<span class="hljs-number">20</span>],b[maxn][<span class="hljs-number">20</span>],f[maxn][<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> aa[maxn],bb[maxn];<br>map &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; ys;<br><span class="hljs-type">int</span> x0;<br><br>pair &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; tmp[<span class="hljs-number">7</span>];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; a,pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; b)</span></span>&#123;<br><span class="hljs-keyword">if</span>(a.first==b.first)<span class="hljs-keyword">return</span> a.second&lt;b.second;<br><span class="hljs-keyword">return</span> a.first&lt;b.first;<br>&#125;<br><br><span class="hljs-comment">//b先行动. </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dp</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)f[i][<span class="hljs-number">0</span>] = aa[bb[i]];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">if</span>(bb[i])b[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">abs</span>(h[bb[i]]-h[i]);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-keyword">if</span>(aa[i])a[i][<span class="hljs-number">0</span>] = <span class="hljs-built_in">abs</span>(h[bb[i]]-h[aa[bb[i]]]);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">19</span>;j++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>f[i][j] = f[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>a[i][j] = a[i][j<span class="hljs-number">-1</span>] + a[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>b[i][j] = b[i][j<span class="hljs-number">-1</span>] + b[f[i][j<span class="hljs-number">-1</span>]][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-type">int</span> p=s;<br><span class="hljs-type">int</span> x1=x;<br>jl1=jl2=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-keyword">if</span> (f[p][i]!=<span class="hljs-number">0</span>&amp;&amp;a[p][i]+b[p][i]&lt;=x1)&#123;<br>x1-=a[p][i]+b[p][i];jl1+=b[p][i];jl2+=a[p][i];p=f[p][i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(bb[p]&amp;&amp;b[p][<span class="hljs-number">0</span>]&lt;=x1)jl1+=b[p][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;h[i];<br>city[i] = <span class="hljs-built_in">node</span>(i,h[i]);<br>s.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">node</span>(i,h[i]));<br>ys[h[i]] = i;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>iter = s.<span class="hljs-built_in">find</span>(city[i]);<br><span class="hljs-type">int</span> t=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(iter!=s.<span class="hljs-built_in">begin</span>())&#123;<br>iter--;<br>tmp[++t] = <span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">abs</span>((*iter).h-city[i].h),(*iter).<br>h);<br><span class="hljs-keyword">if</span> (iter!=s.<span class="hljs-built_in">begin</span>())&#123;<br>iter--;<br>tmp[++t] = <span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">abs</span>((*iter).h-city[i].h),(*iter).h);iter++;<br>&#125;<br>iter++;<br>&#125;<br>iter++;<br><span class="hljs-keyword">if</span>(iter!=s.<span class="hljs-built_in">end</span>())&#123;<br>tmp[++t] = <span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">abs</span>((*iter).h-city[i].h),(*iter).h);iter++;<br><span class="hljs-keyword">if</span> (iter!=s.<span class="hljs-built_in">end</span>())&#123;<br>tmp[++t] = <span class="hljs-built_in">make_pair</span>(<span class="hljs-built_in">abs</span>((*iter).h-city[i].h),(*iter).h);<br>&#125;iter--;<br>&#125;iter--;<br><span class="hljs-built_in">sort</span>(tmp+<span class="hljs-number">1</span>,tmp+t+<span class="hljs-number">1</span>,cmp);<br><span class="hljs-keyword">if</span>(t&gt;=<span class="hljs-number">1</span>)aa[i]=ys[tmp[<span class="hljs-number">1</span>].second];<br><span class="hljs-keyword">if</span>(t&gt;=<span class="hljs-number">2</span>)bb[i]=ys[tmp[<span class="hljs-number">2</span>].second];<br><span class="hljs-comment">//for (int i=1;i&lt;=t;i++)cout&lt;&lt;tmp[i].second&lt;&lt;endl;</span><br><span class="hljs-comment">//cout&lt;&lt;endl&lt;&lt;endl;</span><br>s.<span class="hljs-built_in">erase</span>(iter);<br>&#125;<span class="hljs-comment">/*</span><br><span class="hljs-comment">for (int i=1;i&lt;=n;i++)&#123;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#125;*/</span><br><span class="hljs-built_in">dp</span>();<br>cin&gt;&gt;x0;<br><span class="hljs-type">double</span> now=<span class="hljs-number">2147483647</span>;<br><span class="hljs-type">int</span> ans;<br><span class="hljs-type">int</span> p;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s=<span class="hljs-number">1</span>;s&lt;n;s++)&#123;<br><span class="hljs-built_in">run</span>(s,x0);<br><span class="hljs-keyword">if</span>(jl2!=<span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">double</span>(jl1)/<span class="hljs-built_in">double</span>(jl2)&lt;=now+<span class="hljs-number">0.0000001</span>&amp;&amp;<span class="hljs-built_in">double</span>(jl1)/<span class="hljs-built_in">double</span>(jl2)&gt;=now<span class="hljs-number">-0.0000001</span>)<br><span class="hljs-keyword">if</span>(h[ans]&lt;h[s])ans=s;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">double</span>(jl1)/<span class="hljs-built_in">double</span>(jl2)&lt;now)&#123;<br>ans=s;now=<span class="hljs-built_in">double</span>(jl1)/<span class="hljs-built_in">double</span>(jl2);<br>&#125;<br>&#125;<br>cout&lt;&lt;ans&lt;&lt;endl;<br><span class="hljs-type">int</span> m,s0;<br>cin&gt;&gt;m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>cin&gt;&gt;s0&gt;&gt;x0;<br><span class="hljs-built_in">run</span>(s0,x0);<br>cout&lt;&lt;jl1&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;jl2&lt;&lt;endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>图论</tag>
      
      <tag>排序</tag>
      
      <tag>倍增</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>换教室</title>
    <link href="/2018/10/20/%E9%A2%98%E7%9B%AE/%E6%8D%A2%E6%95%99%E5%AE%A4/"/>
    <url>/2018/10/20/%E9%A2%98%E7%9B%AE/%E6%8D%A2%E6%95%99%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<blockquote><h2 id="description">Description</h2><p>对于刚上大学的牛牛来说,他面临的第一个问题是如何根据实际情况申请合适的课程。在可以选择的课程中,有2n节课程安排在n个时间段上。在第i(1≤i≤n)个时间段上,两节内容相同的课程同时在不同的地点进行,其中,牛牛预先被安排在教室ci上课,而另一节课程在教室di进行。在不提交任何申请的情况下,学生们需要按时间段的顺序依次完成所有的n节安排好的课程。如果学生想更换第i节课程的教室,则需要提出申请。若申请通过,学生就可以在第i个时间段去教室di上课,否则仍然在教室ci上课。由于更换教室的需求太多,申请不一定能获得通过。通过计算,牛牛发现申请更换第i节课程的教室时,申请被通过的概率是一个已知的实数ki,并且对于不同课程的申请,被通过的概率是互相独立的。学校规定,所有的申请只能在学期开始前一次性提交,并且每个人只能选择至多m节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室,而不能根据某些课程的申请结果来决定其他课程是否申请;牛牛可以申请自己最希望更换教室的m门课程,也可以不用完这m个申请的机会,甚至可以一门课程都不申请。因为不同的课程可能会被安排在不同的教室进行,所以牛牛需要利用课间时间从一间教室赶到另一间教室。牛牛所在的大学有v个教室,有e条道路。每条道路连接两间教室,并且是可以双向通行的。由于道路的长度和拥堵程度不同,通过不同的道路耗费的体力可能会有所不同。当第i(1≤i≤n-1)节课结束后,牛牛就会从这节课的教室出发,选择一条耗费体力最少的路径前往下一节课的教室。现在牛牛想知道,申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的期望值最小,请你帮他求出这个最小值。</p><h2 id="input">Input</h2><p>第一行四个整数n,m,v,e。n表示这个学期内的时间段的数量;m表示牛牛最多可以申请更换多少节课程的教室;</p><p>v表示牛牛学校里教室的数量;e表示牛牛的学校里道路的数量。</p><p>第二行n个正整数,第i(1≤i≤n)个正整数表示c,,即第i个时间段牛牛被安排上课的教室;保证1≤ci≤v。</p><p>第三行n个正整数,第i(1≤i≤n)个正整数表示di,即第i个时间段另一间上同样课程的教室;保证1≤di≤v。</p><p>第四行n个实数,第i(1≤i≤n)个实数表示ki,即牛牛申请在第i个时间段更换教室获得通过的概率。保证0≤ki≤1。</p><p>接下来e行,每行三个正整数aj,bj,wj,表示有一条双向道路连接教室aj,bj,通过这条道路需要耗费的体力值是Wj;</p><p>保证1≤aj,bj≤v,1≤wj≤100。</p><p>保证1≤n≤2000,0≤m≤2000,1≤v≤300,0≤e≤90000。</p><p>保证通过学校里的道路,从任何一间教室出发,都能到达其他所有的教室。</p><p>保证输入的实数最多包含3位小数。</p><h2 id="output">Output</h2><p>输出一行,包含一个实数,四舎五入精确到小数点后恰好2位,表示答案。你的</p><p>输出必须和标准输出完全一样才算正确。</p><p>测试数据保证四舎五入后的答案和准确答案的差的绝对值不大于4*10^-3。(如果你不知道什么是浮点误差,这段话</p><p>可以理解为:对于大多数的算法,你可以正常地使用浮点数类型而不用对它进行特殊的处理)</p><h2 id="sample-input">Sample Input</h2><p>3 2 3 3 2 1 2 1 2 1 0.8 0.2 0.5 1 2 5 1 3 3 2 3 1</p><h2 id="sample-output">Sample Output</h2><p>2.80</p></blockquote><p>这是一道概率DP的板子题。</p><p>其实概率DP与普通DP并没有太大区别，明确了状态和状态转移方程，答案就出来了。</p><p>观察数据范围，点数足够小，而且后面会频繁用到最短路，想到使用Floyd预处理出全局最短路。</p><p>考虑每个点选不选，有一个明显的状态在里面，即当前选了的教室的个数，但这样将存在后效性，即当前选不选和后面的最短路决策明显有关，于是将当前选不选也作为一维。</p><p>对于状态的转移，考虑两种决策，即当前选或不选。但注意到在转移时，当前选或不选对期望的影响与上一次选不选有关，分类讨论即可。</p><ol type="1"><li><p>当前不选，上次不选。这样直接是固定的路径，相加即可。</p></li><li><p>当前不选，上次选。两种方式乘上各自的概率即可。</p><p>以上两种当前不选的方式取MIN即可。</p></li><li><p>当前选，上次不选。两条路直接算概率乘距离。</p></li><li><p>当前选，上次选。这是最复杂的情况。因为要分四种情况。上次成功，这次成功。上次失败，这次失败。上次成功，这次失败。上次失败，这次成功。分别计算路径乘概率得到期望。</p><p>以上两种当前选的方式取MIN。</p></li></ol><p>至此我们得到了转移方程，dfs、dp均可得到正解。注意一下边界条件即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> inf=<span class="hljs-number">99999999</span>;<br><br><span class="hljs-type">int</span> n,m,v,e;<br><span class="hljs-type">int</span> c[<span class="hljs-number">2005</span>];<br><span class="hljs-type">int</span> d[<span class="hljs-number">2005</span>];<br><span class="hljs-type">double</span> k[<span class="hljs-number">2005</span>];<br><span class="hljs-type">int</span> g[<span class="hljs-number">303</span>][<span class="hljs-number">303</span>];<br><span class="hljs-type">double</span> dp[<span class="hljs-number">2005</span>][<span class="hljs-number">2005</span>][<span class="hljs-number">3</span>];<br><span class="hljs-type">int</span> a,b,w;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyed</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;=v;k++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=v;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=v;j++)<br>g[i][j] = <span class="hljs-built_in">min</span>(g[i][j],g[i][k]+g[k][j]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;n&gt;&gt;m&gt;&gt;v&gt;&gt;e;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cin&gt;&gt;c[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cin&gt;&gt;d[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)cin&gt;&gt;k[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=v;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;i;j++)<br>g[i][j] = g[j][i] = inf;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=e;i++)&#123;<br>cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;<br>g[a][b] = g[b][a] = <span class="hljs-built_in">min</span>(g[a][b],w);<br>&#125;<br><span class="hljs-built_in">floyed</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=m+<span class="hljs-number">1</span>;j&gt;=<span class="hljs-number">0</span>;j--)<br>dp[i][j][<span class="hljs-number">0</span>]=dp[i][j][<span class="hljs-number">1</span>]=inf;<br><span class="hljs-comment">//cout&lt;&lt;&quot;done&quot;;</span><br>dp[<span class="hljs-number">1</span>][m][<span class="hljs-number">0</span>]=dp[<span class="hljs-number">1</span>][m<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]=<span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=m;j&gt;=<span class="hljs-number">0</span>;j--)&#123;<br>dp[i][j][<span class="hljs-number">0</span>]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">0</span>]+g[c[i<span class="hljs-number">-1</span>]][c[i]],<br><br>dp[i<span class="hljs-number">-1</span>][j][<span class="hljs-number">1</span>]+g[c[i<span class="hljs-number">-1</span>]][c[i]]*(<span class="hljs-number">1.0</span>-k[i<span class="hljs-number">-1</span>])+g[d[i<span class="hljs-number">-1</span>]][c[i]]*k[i<span class="hljs-number">-1</span>]);<br><br>dp[i][j][<span class="hljs-number">1</span>]=<span class="hljs-built_in">min</span>(dp[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>][<span class="hljs-number">0</span>]+g[c[i<span class="hljs-number">-1</span>]][c[i]]*(<span class="hljs-number">1.0</span>-k[i])+g[c[i<span class="hljs-number">-1</span>]][d[i]]*k[i],<br>dp[i<span class="hljs-number">-1</span>][j+<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]+g[c[i<span class="hljs-number">-1</span>]][c[i]]*(<span class="hljs-number">1.0</span>-k[i<span class="hljs-number">-1</span>])*(<span class="hljs-number">1.0</span>-k[i])+g[d[i<span class="hljs-number">-1</span>]][d[i]]*k[i<span class="hljs-number">-1</span>]*k[i]+g[c[i<span class="hljs-number">-1</span>]][d[i]]*(<span class="hljs-number">1.0</span>-k[i<span class="hljs-number">-1</span>])*k[i]+g[d[i<span class="hljs-number">-1</span>]][c[i]]*k[i<span class="hljs-number">-1</span>]*(<span class="hljs-number">1.0</span>-k[i]));<br>&#125;<br>&#125;<br><span class="hljs-type">double</span> ans=inf;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=m;j++)&#123;ans = <span class="hljs-built_in">min</span>(ans,<span class="hljs-built_in">min</span>(dp[n][j][<span class="hljs-number">0</span>],dp[n][j][<span class="hljs-number">1</span>]));<span class="hljs-comment">//cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;</span><br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.2lf&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>NOIP原题</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>货车运输</title>
    <link href="/2018/10/20/%E9%A2%98%E7%9B%AE/%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%EF%BC%88%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E+kruskal+LCA%EF%BC%89/"/>
    <url>/2018/10/20/%E9%A2%98%E7%9B%AE/%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%EF%BC%88%E6%A0%91%E4%B8%8A%E5%80%8D%E5%A2%9E+kruskal+LCA%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>A国有n座城市，编号从 1到n，城市之间有 m条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 q辆货车在运输货物，司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。</p></blockquote><p>对于这道题，容易想到的是一个朴素的算法。即用跑最短路的思路来跑出最小值最大的一条路，只需对spfa进行稍许修改即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(<span class="hljs-built_in">min</span>(d[x],son.w)&gt;d[son.v])<br>    d[son.v]=<span class="hljs-built_in">min</span>(d[x],son.w);<br></code></pre></td></tr></table></figure><p>这种算法是基于最小值最大的路也有和最短/最长路一样的特性，满足三角形不等式，故必然可以用spfa跑。</p><p>朴素算法可以得30分。</p><p>另一种思想是考虑我们要找的是最小值最大的一条路，这满足二分的性质，具有单调性。但是进一步思考，检验一个解的复杂度也是搜索级别的，二分没有意义。</p><p>我们再来仔细想想这个问题本身，一些容量很低的边并且可以不被经过的边是没有意义的，是可以删掉的。按照这个思路，我们其实只需要一颗能尽量把所有点连起来的树，这颗树内的边容量尽量大，那我们只需跑一遍kruskal找最大生成树即可。</p><p>到这一步，问题就从图上转化成在森林上了，而森林上的问题几乎都可以在树上解决。</p><p>首先判断连通性，这一步很简单，用并查集即可，而且前面的kruskal就维护了并查集了。</p><p>若具有连通性，那么这两点一定位于同一颗树内，找这条路径上的边权最小值即可。暴力的复杂度还是很高，我们无法接受。但这个过程明显可以用倍增优化。构造一个数组存每个点第2^i祖先即可。合并时按照二进制拆分的思想进行。这个过程与LCA完全相同，在LCA模板上加入这个数组即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=INT_MAX;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,y,c;<br><span class="hljs-type">int</span> qs;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> v,w,from;<br>    <span class="hljs-built_in">edge</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>)&#123;<br>        from=a;v=b;w=c;<br>    &#125;<br>&#125;;<br><br>vector&lt;edge&gt; g[maxn];<br>edge ed[<span class="hljs-number">5</span>*maxn];<br><span class="hljs-type">int</span> dad[<span class="hljs-number">5</span>*maxn];<br><span class="hljs-type">int</span> tot;<br><span class="hljs-type">int</span> f[maxn][<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> w[maxn][<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> dep[maxn];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(dad[x]==x)<span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> dad[x]=<span class="hljs-built_in">find</span>(dad[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(edge a,edge b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a.w&gt;b.w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kru</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">sort</span>(ed+<span class="hljs-number">1</span>,ed+m+<span class="hljs-number">1</span>,cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> xx=ed[i].from;<span class="hljs-type">int</span> yy=ed[i].v;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(xx)!=<span class="hljs-built_in">find</span>(yy))&#123;<br>            g[xx].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(xx,yy,ed[i].w));<br>            g[yy].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(yy,xx,ed[i].w));<br>            dad[<span class="hljs-built_in">find</span>(xx)]=dad[<span class="hljs-built_in">find</span>(yy)];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>    dep[u]=dep[fa]+<span class="hljs-number">1</span>;<br>    f[u][<span class="hljs-number">0</span>]=fa;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">19</span>;i++)&#123; <span class="hljs-comment">//这里正反很重要！ </span><br>        f[u][i] = f[f[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>        w[u][i] = <span class="hljs-built_in">min</span>(w[u][i<span class="hljs-number">-1</span>],w[f[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-keyword">if</span>(g[u][i].v==fa)<span class="hljs-keyword">continue</span>;<br>        w[g[u][i].v][<span class="hljs-number">0</span>] = g[u][i].w;<br>        <span class="hljs-built_in">dfs</span>(g[u][i].v,u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-type">int</span> ans=inf;<br>    <span class="hljs-keyword">if</span>(dep[x]&lt;dep[y])<span class="hljs-built_in">swap</span>(x,y);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y])&#123;<br>            ans=<span class="hljs-built_in">min</span>(ans,w[x][i]);x=f[x][i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">if</span>(f[x][i]!=f[y][i])&#123;<br>            ans = <span class="hljs-built_in">min</span>(ans,w[x][i]);<br>            ans = <span class="hljs-built_in">min</span>(ans,w[y][i]);<br>            x=f[x][i];y=f[y][i];<br>        &#125;<br>    &#125;<br>    ans = <span class="hljs-built_in">min</span>(ans,w[x][<span class="hljs-number">0</span>]);ans = <span class="hljs-built_in">min</span>(ans,w[y][<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;<br>        ed[++tot] = <span class="hljs-built_in">edge</span>(x,y,c);<br>        dad[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)dad[i]=i;<br>    <span class="hljs-built_in">kru</span>();<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(dep[i]==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//for (register int j=19;j&gt;=1;j--)</span><br>    <span class="hljs-comment">//    for (register int i=1;i&lt;=n;++i)&#123;</span><br>    <span class="hljs-comment">//        f[i][j]=f[f[i][j-1]][j-1];</span><br>    <span class="hljs-comment">//        w[i][j]=min(w[i][j-1],w[f[i][j-1]][j-1]);</span><br>    <span class="hljs-comment">//    &#125;</span><br>    cin&gt;&gt;qs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=qs;i++)&#123;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x)!=<span class="hljs-built_in">find</span>(y))&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<span class="hljs-keyword">continue</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-built_in">lca</span>(x,y)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面这是直接套kruskal重构树的板子写的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn=<span class="hljs-number">100005</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf=INT_MAX;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> x,y,c;<br><span class="hljs-type">int</span> qs;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> v,w,from;<br>    <span class="hljs-built_in">edge</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>)&#123;<br>        from=a;v=b;w=c;<br>    &#125;<br>&#125;;<br><br>vector&lt;edge&gt; g[<span class="hljs-number">4</span>*maxn];<br>edge ed[<span class="hljs-number">5</span>*maxn];<br><span class="hljs-type">int</span> dad[<span class="hljs-number">5</span>*maxn];<br><span class="hljs-type">int</span> tot;<br><span class="hljs-type">int</span> f[maxn][<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> dep[maxn];<br><span class="hljs-type">int</span> d[<span class="hljs-number">2</span>*maxn];<br><span class="hljs-type">int</span> t;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dad[x]==x)<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">return</span> dad[x]=<span class="hljs-built_in">find</span>(dad[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(edge a,edge b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a.w&gt;b.w;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kru</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">sort</span>(ed+<span class="hljs-number">1</span>,ed+m+<span class="hljs-number">1</span>,cmp);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br><span class="hljs-type">int</span> xx=ed[i].from;<span class="hljs-type">int</span> yy=ed[i].v;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(xx)!=<span class="hljs-built_in">find</span>(yy))&#123;<br>d[++t] = ed[i].w;<br>g[t].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(t,<span class="hljs-built_in">find</span>(yy),<span class="hljs-number">0</span>));<br>g[<span class="hljs-built_in">find</span>(yy)].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(<span class="hljs-built_in">find</span>(yy),t,<span class="hljs-number">0</span>));<br>g[t].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(t,<span class="hljs-built_in">find</span>(xx),<span class="hljs-number">0</span>));<br>g[<span class="hljs-built_in">find</span>(xx)].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(<span class="hljs-built_in">find</span>(xx),t,<span class="hljs-number">0</span>));<br>dad[<span class="hljs-built_in">find</span>(xx)]=dad[<span class="hljs-built_in">find</span>(yy)]=dad[t]=t;<span class="hljs-comment">//这里 </span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>dep[u]=dep[fa]+<span class="hljs-number">1</span>;<br>f[u][<span class="hljs-number">0</span>]=fa;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">19</span>;i++)&#123;<br>    f[u][i] = f[f[u][i<span class="hljs-number">-1</span>]][i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g[u].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">if</span>(g[u][i].v==fa)<span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">dfs</span>(g[u][i].v,u);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep[x]&lt;dep[y])<span class="hljs-built_in">swap</span>(x,y);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y])&#123;<br>x=f[x][i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span> x;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">19</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-keyword">if</span>(f[x][i]!=f[y][i])&#123;<br>x=f[x][i];y=f[y][i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    t=n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;x&gt;&gt;y&gt;&gt;c;<br>        ed[++tot] = <span class="hljs-built_in">edge</span>(x,y,c);<br>        dad[i]=i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)dad[i]=i;<br>    <span class="hljs-built_in">kru</span>();<br><span class="hljs-built_in">dfs</span>(t,<span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">if</span>(dep[i]==<span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-built_in">find</span>(i),<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br>    cin&gt;&gt;qs;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=qs;i++)&#123;<br>        cin&gt;&gt;x&gt;&gt;y;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x)!=<span class="hljs-built_in">find</span>(y))&#123;<br>        cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;endl;<span class="hljs-keyword">continue</span>;<br>&#125;<br>        cout&lt;&lt;d[<span class="hljs-built_in">lca</span>(x,y)]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>图论</tag>
      
      <tag>kruskal</tag>
      
      <tag>LCA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>背包问题</title>
    <link href="/2018/10/20/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/DP%E4%B8%93%E9%A2%98/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2018/10/20/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/DP%E4%B8%93%E9%A2%98/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="背包问题">背包问题</h2><p>对背包问题状态转移方程的一个证明。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=m;j&gt;=v[i];j--)&#123;<br>      f[j]=<span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+<span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>使用数学归纳法。</p><p>首先考虑只有一个物品的情况。这种情况很简单，选一定比不选好。</p><p>其次，假设我们已经得到了有n个物品情况的最优解，我们来尝试推出有n+1个物品时的最优解。</p><p>对于任意一个合法的j，此时无非只有两种决策，选或不选，依次考虑这两种情况即可。所以算法得到的一定是最优解。</p><h3 id="t1">T1:</h3><blockquote><p>一共有n件食材，每件食材有三个属性，ai，bi和ci，如果在t时刻完成第i样食材则得到ai-t*bi的美味指数，用第i件食材做饭要花去ci的时间。</p><p>众所周知，gw的厨艺不怎么样，所以他需要你设计烹调方案使得美味指数最大</p></blockquote><p>可以看到，在本题中食材的价值是一个随着t变化的函数。</p><p>应该意识到<strong>在最终的答案中</strong>b越大的越应该放前面，因为这样才能使整体的价值最大。</p><p><strong>在最终的答案中</strong>c越大的越应该放后面，因为这样才能使那些c大的食材不至于“阻塞”后面的食材。</p><p>b和c一起似乎可以确定某种顺序，我们来考虑从数学上计算一下。 <spanclass="math display">\[考虑两个相邻的对象。\\S_1 = a_i-t_0*b_i\\S_2 = a_{i+1}-(t_0+c_i)*b_{i+1}\\则它们的价值和为\\T_1 = (a_i+a_{i+1})-(b_i+b_{i+1})*t_0-c_i*b_{i+1}\\而如果将这两个对象交换。\\S_1 = a_i - (t_0+c_{i+1})*b_i\\S_2 = a_{i+1} -t_0*b_{i+1}\\则此时价值和为\\T_2 = (a_i+a_{i+1})-(b_i+b_{i+1})*t_0-c_{i+1}*b_i\\易得T_1&gt;T_2的充分必要条件为\\c_i*b_{i+1} &lt; c_{i+1}*b_i\]</span>由冒泡排序的思想，这必然可以确定一个顺序。即对于任意的两个物品x，y。如果有b[x]*c[y]&lt;b[y]*c[x]则<strong>在最终的答案中</strong>x一定在y的前面。</p><p>那么在DP时按这个顺序枚举是否就能保证答案的正确性呢？</p><p>答案是肯定的。</p><p>我们来考虑一下背包DP中，物品种类的枚举顺序的意义是什么。因为在本题中时间是一维状态，为什么枚举的顺序对它有影响呢？</p><p>事实上，首先，如果不按这个顺序枚举，是一定无法得到最优解的，只有按这个顺序枚举，才<strong>可能</strong>得到最优解。也就是说这个顺序是最优解的<strong>必要</strong>条件。</p><p>因为背包DP本质上也是一种刷表法（这一点可以用滚动数组优化之前的朴素方法来考虑），是从上一个最优解转移到下一个多了一种物品选择的最优解。而上一个最优解中可能已经选了一些物品，而这可能破坏掉最优解的必要条件。</p><p>但如果我们按排好序后的枚举，则不会破坏必要条件，且按照前面对背包DP正确性的证明，它考虑了每一种合法的情况，因而一定可以得到最优解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>DP</tag>
      
      <tag>背包问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>棋盘DP</title>
    <link href="/2018/10/20/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/DP%E4%B8%93%E9%A2%98/%E6%A3%8B%E7%9B%98DP/"/>
    <url>/2018/10/20/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/DP%E4%B8%93%E9%A2%98/%E6%A3%8B%E7%9B%98DP/</url>
    
    <content type="html"><![CDATA[<h2 id="t1最大正方形">T1:最大正方形</h2><blockquote><p>在一个n*m的只包含0和1的矩阵里找出一个不包含0的最大正方形，输出边长。</p></blockquote><p>先考虑暴力，枚举起点和边长，可以O(n^5)的解决这个问题。稍作优化（这个优化第一次看见好像还是在初赛）</p><p>采用f[i][j]表示第i行前j个元素的前缀和。这样计算一个矩阵的元素和的复杂度可以降至O(n)。总复杂度可以降至O(n^4)。</p><p>再稍微优化优化</p><p>直接计算二维矩阵前缀和，预处理的复杂度为O(n<sup>2)，计算的复杂度为O(1)，总复杂度为O(n</sup>3)。</p><p>再优化</p><p>对于边长其实可以不用枚举，而可以二分。明显它具有单调性。总复杂度降至O(logn*n^2)。</p><p>但是！！！</p><p>这些方法都不行。</p><p>不是复杂度太丑，就是代码太丑，这题。。。可以DP呀。</p><p>我们的时间复杂度很多浪费在了对不可能的矩形进行检查，应该意识到，只有自己是1的点才能参与构造矩形。我们只需尝试将这个点往其它方向扩展即可。考虑使用悬线法。</p><h3 id="悬线法">悬线法</h3><p>用途：解决给定矩阵中满足条件的最大子矩阵。</p><p>做法：用一条线左右移动直到不满足约束条件或到达边界。</p><p>定义这几个东西：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">left[i][j]<span class="hljs-comment">//代表从(i,j)能到达的最左位置</span><br>right[i][j]<span class="hljs-comment">//代表从(i,j)能到达的最右位置</span><br>up[i][j]<span class="hljs-comment">//代表从(i,j)向上扩展最长长度.</span><br></code></pre></td></tr></table></figure><p>然后先进行横向扩展</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs CPP"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]&amp;&amp;a[i][j<span class="hljs-number">-1</span>])le[i][j] = le[i][j<span class="hljs-number">-1</span>];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=m<span class="hljs-number">-1</span>;j&gt;=<span class="hljs-number">1</span>;j--)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]&amp;&amp;a[i][j+<span class="hljs-number">1</span>])ri[i][j] = ri[i][j+<span class="hljs-number">1</span>];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再纵向扩展</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-keyword">if</span>(a[i][j]&amp;&amp;a[i<span class="hljs-number">-1</span>][j])&#123;<br>le[i][j] = <span class="hljs-built_in">max</span>(le[i][j],le[i<span class="hljs-number">-1</span>][j]);<br>ri[i][j] = <span class="hljs-built_in">min</span>(ri[i][j],ri[i<span class="hljs-number">-1</span>][j]);<br>up[i][j] = up[i<span class="hljs-number">-1</span>][j]+<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后统计答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=m;j++)&#123;<br><span class="hljs-type">int</span> c = ri[i][j]-le[i][j]+<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-built_in">min</span>(c,up[i][j]);<br>ans = <span class="hljs-built_in">max</span>(ans,b);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是考虑这样一种情况。</p><p>按照我们的状态转移方程，我们求出的是黑色部分的面积。但若红色部分的面积更大我们岂不是漏解了？</p><figure><img src="https://i.loli.net/2018/09/26/5bab89cbcd43c.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>不是的，红色部分的面积会被蓝色left，right数组还未更新的地方更新。</p><figure><img src="https://i.loli.net/2018/09/26/5bab8b760377f.png" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>但是这题还可以优化。因为悬线法可以针对所有矩形，而此题只需正方形。所以我们不选择横向和纵向扩展，而是直接斜着扩展，<strong>这也是正方形棋盘dp中的常用方法</strong>。</p><p>定义f[i][j]表示以节点i,j为右下角，可构成的最大正方形的边长。</p><p>只有a[i][j]==1时，节点i,j才能作为正方形的右下角；</p><p>对于一个已经确定的f[i][j]=x，它表明包括节点i，j在内向上x个节点，向左x个节点扫过的正方形中所有a值都为1。</p><p>那么易得状态转移方程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> (a[i][j]==<span class="hljs-number">1</span>) f[i][j]=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">min</span>(f[i][j<span class="hljs-number">-1</span>],f[i<span class="hljs-number">-1</span>][j]),f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>完成后在所有f[i][j]中取max即可。</p><h2 id="t2棋盘制作">T2:棋盘制作</h2><blockquote><p>国际象棋是世界上最古老的博弈游戏之一，和中国的围棋、象棋以及日本的将棋同享盛名。据说国际象棋起源于易经的思想，棋盘是一个8×8大小的黑白相间的方阵，对应八八六十四卦，黑白对应阴阳。</p><p>而我们的主人公<code>小Q</code>，正是国际象棋的狂热爱好者。作为一个顶尖高手，他已不满足于普通的棋盘与规则，于是他跟他的好朋友<code>小W</code>决定将棋盘扩大以适应他们的新规则。</p><p><code>小Q</code>找到了一张由N×M个正方形的格子组成的矩形纸片，每个格子被涂有黑白两种颜色之一。<code>小Q</code>想在这种纸中裁减一部分作为新棋盘，当然，他希望这个棋盘尽可能的大。</p><p>不过<code>小Q</code>还没有决定是找一个正方形的棋盘还是一个矩形的棋盘（当然，不管哪种，棋盘必须都黑白相间，即相邻的格子不同色），所以他希望可以找到最大的正方形棋盘面积和最大的矩形棋盘面积，从而决定哪个更好一些。</p><p>于是<code>小Q</code>找到了即将参加全国信息学竞赛的你，你能帮助他么？</p></blockquote><p>悬线法秒掉即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LCA</title>
    <link href="/2018/10/19/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/LCA/"/>
    <url>/2018/10/19/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/LCA/</url>
    
    <content type="html"><![CDATA[<p>LCA即最近公共祖先，这里只介绍倍增这一种求法。复杂度为O((n+q)logn)。</p><p>算法基于倍增的思想。即当前节点的第2<sup>n祖先等于当前节点的2</sup>(n-1)祖先的2<sup>(n-1)祖先。用这个思想可以在logn复杂度内处理一个节点的所有2</sup>i祖先。且可以证明的是，处理深度更大的节点的时候，深度小的节点的信息已经处理完毕。</p><p>在预处理倍增f数组的时候，还可以做：</p><ol type="1"><li>求dfs序。</li><li>求深度。</li><li>丢到根距离，用于进一步求路径距离。</li></ol><p>预处理完毕后，求lca：</p><ol type="1"><li>将两个点深度大的往上跳，直到将深度调整的一致。如果此时已经是同一个点，直接返回。</li><li>将两个点一起往上跳，直到不能跳为止。</li><li>返回x或y的父节点。</li></ol><p>注意几个循环的顺序。</p><p>dfs中，倍增的那个循环<strong>必须正着跑</strong>，因为后面的值对前面的有依赖。</p><p>lca中的两个循环必须反着跑，这是二进制拆分的思想，从大到小才能唯一表示出一个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 555555</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> n, m, s;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-type">int</span> a, b;<br>vector&lt;<span class="hljs-type">int</span>&gt; g[M];<br><span class="hljs-type">int</span> f[M][<span class="hljs-number">20</span>];<br><span class="hljs-type">int</span> dep[M];<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-type">int</span> s=<span class="hljs-number">0</span>,w=<span class="hljs-number">1</span>;<br>   <span class="hljs-type">char</span> ch=<span class="hljs-built_in">getchar</span>();<br>   <span class="hljs-keyword">while</span>(ch&lt;=<span class="hljs-string">&#x27;0&#x27;</span>||ch&gt;<span class="hljs-string">&#x27;9&#x27;</span>)&#123;<span class="hljs-keyword">if</span>(ch==<span class="hljs-string">&#x27;-&#x27;</span>)w=<span class="hljs-number">-1</span>;ch=<span class="hljs-built_in">getchar</span>();&#125;<br>   <span class="hljs-keyword">while</span>(ch&gt;=<span class="hljs-string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="hljs-string">&#x27;9&#x27;</span>) s=s*<span class="hljs-number">10</span>+ch-<span class="hljs-string">&#x27;0&#x27;</span>,ch=<span class="hljs-built_in">getchar</span>();<br>   <span class="hljs-keyword">return</span> s*w;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> father)</span> </span>&#123;<br>    dep[u] = dep[father] + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">18</span>; i++) &#123;<br>        f[u][i + <span class="hljs-number">1</span>] = f[f[u][i]][i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g[u].<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> v = g[u][i];<br>        <span class="hljs-keyword">if</span> (v == father) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        f[v][<span class="hljs-number">0</span>] = u;<br>        <span class="hljs-built_in">dfs</span>(v, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dep[x] &lt; dep[y])<span class="hljs-built_in">swap</span>(x, y);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">19</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (dep[f[x][i]] &gt;= dep[y])x = f[x][i];<br>        <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> x;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">19</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (f[x][i] != f[y][i]) &#123;<br>            x = f[x][i]; y = f[y][i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>,&amp;n,&amp;m,&amp;s);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n<span class="hljs-number">-1</span>; i++) &#123;<br>        x=<span class="hljs-built_in">read</span>();y=<span class="hljs-built_in">read</span>();<br>        g[x].<span class="hljs-built_in">push_back</span>(y); g[y].<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        a=<span class="hljs-built_in">read</span>();b=<span class="hljs-built_in">read</span>();<br>        ans = <span class="hljs-built_in">lca</span>(a, b);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,ans);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>图论</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kruskal重构树</title>
    <link href="/2018/10/19/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/"/>
    <url>/2018/10/19/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/kruskal%E9%87%8D%E6%9E%84%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h2 id="kruskal重构树的性质">kruskal重构树的性质</h2><p>kruskal是在kruskal进行的过程中，把最小生成树的边权变为点权的算法。这样，重构出的树的结点数为n + (n-1) = 2n -1.个，并且这棵树具有以下性质：</p><ol type="1"><li>这是一个二叉堆。</li><li>原树两点间边权的最大（最小）值为两点LCA的权值。</li><li>重构树中原树的节点全部为叶子节点，其余节点都是新建的点。</li></ol><h2 id="kruskal重构树的构造">kruskal重构树的构造</h2><p>与kruskal类似。先对边进行排序，然后使用并查集辅助加边。新建一条边时，进行以下操作：</p><ol type="1"><li>新建节点（编号从N+1开始）（点权为对应边权）。</li><li>把原有两点<strong>和新建的点</strong>加入并查集维护。</li><li>把原有两点<strong>所在子树</strong>连到新建节点上。</li></ol><p>算法进行完毕后，若原图联通，则我们建立出的必然是一棵以最后新建的节点为根的有根树。</p><p>若原图不连通，则建出的为一个森林。</p><p>此时可以遍历每个节点，将其并查集的根作为树的根。</p><p>（因为在并查集的根就是最后加的节点）</p><p><img src="https://cdn.luogu.org/upload/pic/38213.png" /></p><p>下面，我们来一一考察我们前面说的kruskal重构树的性质。</p><p>为了方便性质的说明，<strong>不妨设</strong>边是从小到大排序的，因为这和从大到小排序的情况是基本相同的。</p><p>首先，考虑我们对每次加点的处理。有两种情况，第一，由两个原图上的点直接生成，这样一定是二叉的。第二，由一个原图上的点和一个之前生成的新点构成，这样还是二叉的。再考虑到我们加点的顺序，根据kruskal算法，我们是按照边权进行排序加点的，后加的点一定大于先加的点，又后加的点的深度一定小于等于先加的点的深度，故这是一个大根堆。</p><p>现在我们来对性质的第三点进行说明。其实这一点很容易理解，因为对于任意一个原图上的点，它必然有父节点且必然没有子节点，所以它是叶子节点。</p><p>现在我们来对性质里面的第二点进行说明。</p><p>第一，不难发现原图两点间的最大值最小的路径与原图的最小生成树中的两点间最大值最小的路径完全相同。因为在构建最小生成树的过程中是舍弃掉了一些边权很大的边，对这条路径不会产生影响。</p><p>第二，考虑kruskal重构树中两点LCA的意义，由于LCA只往上走而不往下走，而这是一个大根堆，所以即尽量走边权大的边，这样可以保证走出的路径一定是最优的。又这两点的lca是这条路径中边权最大的边重构成的点，故这即为所求。</p><h2 id="应用">应用</h2><p>基础应用比如求最小值最大，最大值最小的路径等。</p><p>还可以处理一些计算边对点的贡献的题。</p><blockquote><p>给定一个带权树，树上任意两点间的路径权值d(x,y)定义为x,y这两个点之间路径上的最小值，树上任意一点x的权值定义为这个点到树上其他所有点的路径权值和，即<span class="math display">\[\sum_{i=1}^{n}d(x,i)\]</span> ，现求树上一点，使得这个点的权值最大，输出这个值。</p></blockquote><p>显然不可能暴力。</p><p>考虑计算每条边造成的贡献。显然一条边对所有路径经过这条边的点对都有贡献。</p><p>考虑使用kruskal重构树来计算。</p><p>原树中的边即为重构树中的非叶子节点。</p><p>从这些点的左子树到右子树必然经过这条边，且由kruskal重构树的性质，这条边是路径中最短的那条边，就可以统计该点的贡献。</p><p>区间加法使用树状数组维护即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>图论</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树上差分</title>
    <link href="/2018/10/18/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/"/>
    <url>/2018/10/18/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>树上差分有两种形式，关于点的差分和边的差分。</p><p>先来考虑边的差分：</p><p>边的差分是用于解决边的覆盖问题的一种很优雅的方式。</p><p>具体方式为读入一条路径。对路径的起点，终点+1，对起点和终点的LCA-2.</p><p><img src="https://cdn.luogu.org/upload/pic/20327.png" /></p><p>统计一条边被覆盖的次数时只需统计这条边连的点中深度较大的那个点和它的子树的差分和即可。</p><p>另一种是关于点的差分：</p><p>点的差分可以用于解决路径覆盖点的次数的问题。</p><p>具体方式为读入一条路径，将起点和终点+1，将lca-1，将lca的父节点-1。</p><p><img src="https://cdn.luogu.org/upload/pic/20328.png" /></p><p>统计一个点被覆盖的次数即计算这个点和它的子树的差分和。</p><p>一个小trick：</p><p>求子树差分和时可以不用再单独跑一个dfs，可以在前面dfs的时候处理好dfs序，这样可以实现一行代码求差分和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>cf[f[num[i]][<span class="hljs-number">0</span>]]+=cf[num[i]];<br></code></pre></td></tr></table></figure><p>dfs序可以保证是从下往上加的，加这个点的时候这个点的下面所有节点都被加上了，顾可以保证差分和的正确性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>图论</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跳石头</title>
    <link href="/2018/10/18/%E9%A2%98%E7%9B%AE/%E8%B7%B3%E7%9F%B3%E5%A4%B4%EF%BC%88%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%EF%BC%89/"/>
    <url>/2018/10/18/%E9%A2%98%E7%9B%AE/%E8%B7%B3%E7%9F%B3%E5%A4%B4%EF%BC%88%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有NN块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。</p><p>为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走MM 块岩石（不能移走起点和终点的岩石）。</p><p>求最短距离的最大值。</p></blockquote><p>看到最小值最大或最大值最小，第一反应应该就是二分。但是笔者并没有往下想，而是在考虑贪心的做法。其实应该先往下想一想再否定掉一个思路（启发式深搜比广搜优）。</p><p>想到二分应该考虑这两点。</p><ol type="1"><li>是否具有单调性。对于本题而言，明显二分答案具有单调性。如果最短距离的最大值可以是d，那么一定能是一个比d小的值。如果最短距离的最大值不能是d，那么一定不能是一个比d大的值。</li><li>如何设计高效的判断函数。对于本题而言，可以贪心的看。从前往后扫一遍，如果当前枚举到的石头和后面一个石头冲突，那么明显的，这两个石头至少要去掉一个。明显的，去掉后面一个对于后面的局势更有利。</li></ol><p>还需注意的是，整数二分的时候如果把边界条件写成 while(l&lt;r)可能会死循环。比如9+10=19,19/2=9。所以要写成 while(l+1&lt;r)。但是这引入了一个新的问题。比如对于在数组[0,1]上二分的时候，可能无法得到正解（上来就终止循环）。解决方案是使l+1 。</p><p>本题要注意起点和终点的石头没有直接给出，需要自己加上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">50005</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> len,m;<br><span class="hljs-type">int</span> a[maxn];<br><span class="hljs-type">int</span> b[maxn];<br><span class="hljs-type">int</span> l,r,mid;<br><span class="hljs-comment">//有操作的 </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">jg</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span></span>&#123;<br><span class="hljs-type">int</span> now=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n+<span class="hljs-number">1</span>;i++)b[i]=a[i];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n+<span class="hljs-number">1</span>;i++)&#123;<br><span class="hljs-keyword">if</span>(b[i+<span class="hljs-number">1</span>]-b[i]&lt;d)&#123;<br>now++;b[i+<span class="hljs-number">1</span>]=b[i];<br><span class="hljs-keyword">if</span>(now&gt;m)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>cin&gt;&gt;len&gt;&gt;n&gt;&gt;m;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>cin&gt;&gt;a[i];<br>&#125;<br>a[n+<span class="hljs-number">1</span>]=len;<br>l=<span class="hljs-number">1</span>;r=len+<span class="hljs-number">1</span>;<br>      <span class="hljs-keyword">while</span>(l+<span class="hljs-number">1</span>&lt;r)&#123;<br>mid = (l+r)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">jg</span>(mid))l=mid;<br><span class="hljs-keyword">else</span> r=mid;<br>&#125;<br>cout&lt;&lt;l&lt;&lt;endl;<br><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>整数二分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运输计划</title>
    <link href="/2018/10/18/%E9%A2%98%E7%9B%AE/%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92%EF%BC%88%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86+LCA+%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%EF%BC%89/"/>
    <url>/2018/10/18/%E9%A2%98%E7%9B%AE/%E8%BF%90%E8%BE%93%E8%AE%A1%E5%88%92%EF%BC%88%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86+LCA+%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>公元20442044 年，人类进入了宇宙纪元。</p><p>L 国有 nn 个星球，还有 n-1n−1条双向航道，每条航道建立在两个星球之间，这 n-1n−1 条航道连通了 LL国的所有星球。</p><p>小 P 掌管一家物流公司，该公司有很多个运输计划，每个运输计划形如：有一艘物流飞船需要从 u_iui号星球沿最快的宇航路径飞行到 v_ivi号星球去。显然，飞船驶过一条航道是需要时间的，对于航道jj，任意飞船驶过它所花费的时间为t_jtj，并且任意两艘飞船之间不会产生任何干扰。</p><p>为了鼓励科技创新， LL 国国王同意小 PP 的物流公司参与 LL国的航道建设，即允许小PP把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。</p><p>在虫洞的建设完成前小 P 的物流公司就预接了 mm个运输计划。在虫洞建设完成后，这 mm个运输计划会同时开始，所有飞船一起出发。当这 mm 个运输计划都完成时，小PP 的物流公司的阶段性工作就完成了。</p><p>如果小 PP 可以自由选择将哪一条航道改造成虫洞， 试求出小 PP的物流公司完成阶段性工作所需要的最短时间是多少？</p></blockquote><p>有n个点，n-1条边的连通图，这必然是一棵树。</p><p>注意到所有运输计划是同时开始的，这意味着我们需要使这些运输计划需要的时间的最大值最小。看到这个问题的形式，容易联想到二分答案。</p><p>明显的，这个问题具有单调性，满足二分条件。因为如果时间可以是t，那么一定可以是大于t，如果时间不能是t，一定不能是小于t。</p><p>再来考虑判断函数的设计。我们需要判断时间为t时，所有运输计划是否可以完成。最朴素的方法是枚举每条航道通过的所有边，删掉之后再跑一次所有航道，看是否可行。</p><p>但是有一个明显的优化，即考虑删掉一条边对我们的收益，明显的，它被覆盖的次数越多，以及它越长，那么把它删掉我们的收益越大。但是不能直接贪心，因为这样只能让和最小，而不能让最大值最小。此时二分的优势就体现出来了，我们只用判断可不可行，而不用得到最优解。所以我们可以把路径长度大于t的单独拿出来考虑。</p><p>如果不存在路径长度大于t的路径，则一定可行。</p><p>如果所有路径长度大于t的路径没有一个公共边，则一定不可行。因为我们只能删掉一条边。如果它们没有一个公共边，则删完之后一定还存在长度大于t的路径。</p><p>如果存在公共边，我们取这些边中长度最大的，删掉。（前面讨论过，这种删法对我们最有利）。再考虑大于t的路径中长度最大的再删完这条边后是否合法，若合法，则方案合法，若不合法，则方案不合法。</p><p>算法大致已经设计完成，我们来看看其中具体的实现细节。</p><p>对于路径求交，我们可以使用树上差分来实现。</p><p>对于路径求长度，可以使用LCA来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">300050</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-type">int</span> sumw;<br><span class="hljs-type">int</span> x,y,c;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br><span class="hljs-type">int</span> v,w;<br><span class="hljs-built_in">edge</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>)&#123;<br>v=a;w=b;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> dep[maxn];<br><span class="hljs-type">int</span> f[maxn][<span class="hljs-number">24</span>];<br>vector &lt;edge&gt; g[maxn];<br><span class="hljs-type">int</span> d[maxn];<br><span class="hljs-type">int</span> cf[maxn];<br><span class="hljs-type">int</span> num[maxn];<br><span class="hljs-type">int</span> numm;<br><span class="hljs-type">int</span> dr[maxn];<br><span class="hljs-type">int</span> le,ri;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">lian</span>&#123;<br><span class="hljs-type">int</span> u,v;<br><span class="hljs-type">int</span> dis,root;<br><span class="hljs-built_in">lian</span>(<span class="hljs-type">int</span> a=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> b=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> c=<span class="hljs-number">0</span>,<span class="hljs-type">int</span> d=<span class="hljs-number">0</span>)&#123;<br>u=a;v=b;dis=d;root=c;<br>&#125;<br>&#125;;<br>lian l[maxn];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br><span class="hljs-comment">//这里求一下dfs序 </span><br>numm++;<br>num[numm]=u;  <span class="hljs-comment">//这里 </span><br><span class="hljs-comment">//这里求一下深度 </span><br>dep[u] = dep[fa] + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//以下为标准lca预处理 </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">22</span>;i++)&#123;<br>f[u][i+<span class="hljs-number">1</span>] = f[f[u][i]][i];<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;g[u].<span class="hljs-built_in">size</span>();i++)&#123;<br><span class="hljs-keyword">if</span>(fa==g[u][i].v)<span class="hljs-keyword">continue</span>;<br><span class="hljs-comment">//这里一行代码求到根距离 </span><br>dr[g[u][i].v]=dr[u]+g[u][i].w;<br>f[g[u][i].v][<span class="hljs-number">0</span>] = u;<br><span class="hljs-built_in">dfs</span>(g[u][i].v,u);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br><span class="hljs-keyword">if</span>(dep[x]&lt;dep[y])<span class="hljs-built_in">swap</span>(x,y);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">23</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-keyword">if</span>(dep[f[x][i]]&gt;=dep[y])x = f[x][i];<br><span class="hljs-keyword">if</span>(x==y)<span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">23</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-keyword">if</span>(f[x][i]!=f[y][i])&#123;<br>        x = f[x][i];y = f[y][i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> f[x][<span class="hljs-number">0</span>];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">jg</span><span class="hljs-params">(<span class="hljs-type">int</span> t)</span></span>&#123;<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">memset</span>(cf,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(cf));<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    <span class="hljs-keyword">if</span>(l[i].dis&gt;t)&#123;<br> cf[l[i].u]+=<span class="hljs-number">1</span>;<br> cf[l[i].v]+=<span class="hljs-number">1</span>;<br> cf[l[i].root]-=<span class="hljs-number">2</span>;<br> cnt++;<br> ans = <span class="hljs-built_in">max</span>(ans,l[i].dis-t);<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(cnt==<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)<br>cf[f[num[i]][<span class="hljs-number">0</span>]]+=cf[num[i]];<br><span class="hljs-comment">//注意这里是2</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">2</span>;i&lt;=n;i++)<br><span class="hljs-keyword">if</span>(cf[i]==cnt&amp;&amp;dr[i]-dr[f[i][<span class="hljs-number">0</span>]]&gt;=ans)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n<span class="hljs-number">-1</span>;i++)&#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;c);<br>g[x].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(y,c));<br>g[y].<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">edge</span>(x,c));<br>sumw += c;<br>&#125;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>    l[i] = <span class="hljs-built_in">lian</span>(x,y,<span class="hljs-built_in">lca</span>(x,y),dr[x]+dr[y]<span class="hljs-number">-2</span>*dr[<span class="hljs-built_in">lca</span>(x,y)]);<br>&#125;<br><br>le=<span class="hljs-number">0</span>;ri=sumw+<span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (le&lt;ri)&#123;<br><span class="hljs-type">int</span> mid = (le+ri)&gt;&gt;<span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">jg</span>(mid))ri=mid;<br><span class="hljs-keyword">else</span> le=mid+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,le);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>图论</tag>
      
      <tag>树</tag>
      
      <tag>NOIP原题</tag>
      
      <tag>LCA</tag>
      
      <tag>整数二分</tag>
      
      <tag>树上差分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>exgcd</title>
    <link href="/2018/10/18/%E6%95%B0%E8%AE%BA/exgcd/"/>
    <url>/2018/10/18/%E6%95%B0%E8%AE%BA/exgcd/</url>
    
    <content type="html"><![CDATA[<h1 id="exgcd逆元">exgcd&amp;逆元</h1><h2 id="简介">简介</h2><p>用于求方程形如　ax + by = gcd(a,b)的一个特解（亦可用此解推出所有解）。</p><h2 id="算法">算法</h2><p>递归求解，其实本质是用方程</p><p>bx + (a mod b)y = gcd(b,a mod b)</p><p>的解递推出方程</p><p>ay0 + bx0 = gcd(a,b)</p><p>的解。具体递推关系为</p><p>x0 = y, y0 = x - a/b*y</p><p>递归的边界条件为当a mod b递归至0，则必有gcd(a,b)=b，则此时方程为</p><p>bx = b</p><p>则x=1，y为任意值，不妨设它为0.</p><p>递推关系的证明很显然，直接将模的形式化为除的形式（a mod b = a -a/b*b），然后以a，b为主元变形后将a，b的系数直接相等，即可得到递推关系。</p><h3 id="下面考虑求其它解">下面考虑求其它解</h3><p>设已知一个解(x0,y0)，欲求解(x,y)，则由定义</p><p>ax0 + by0 = gcd(a,b) = ax + by</p><p>简单变形得</p><p>a(x - x0) = b(y0 - y)</p><p>由定义，必有</p><p>gcd(a,b) | a ，gcd(a,b) | b</p><p>则两边同除以gcd(a,b)得</p><p>a'(x - x0) = b'(y0 - y)</p><p>其中a'与b'互质，则必有</p><p>b' | (x - x0)，a' | (y0 - y)</p><p>则两边同除以b'，得</p><p>a'k = y0 - y</p><p>y = y0 - a'k</p><p>又有</p><p>b'k = x - x0</p><p>x = x0 + b'k</p><p>则其它解为(x0 + b'k , y0 - a'k)其中k可取任何整数。</p><h3 id="下面考虑将方程中的-gcdab推广至任意整数c">下面考虑将方程中的gcd(a,b)推广至任意整数c</h3><p>即ax + by = c</p><p>首先，这个方程不一定 有解，方程有解条件为</p><p>gcd(a,b) | c</p><p>且这是一个充分必要条件。</p><p>证明如下</p><p>gcd(a,b) | a , gcd(a,b) | b</p><p>gcd(a,b) | (ax + by)</p><p>所以必有</p><p>gcd(a,b) | c</p><p>才能使方程有解且必有解。</p><p>注意到，此方程要么无解，要么有无数解。</p><p>tip：观察这个方程的形式，它也是一个直线方程，方程有解的意义便是该直线过整点。</p><p>下面考虑有解情况下解的求法，因为</p><p>gcd(a,b) | c</p><p>设</p><p>c = k*gcd(a,b)</p><p>然后可以先求方程</p><p>ax + by = gcd(a,b)</p><p>的解(x0,y0)</p><p>则易得原方程解为(kx0,ky0)</p><h2 id="应用">应用</h2><h3 id="求逆元">求逆元</h3><p>即求a在mod p剩余系下的逆元x</p><p>则ax = 1(mod p)</p><p>即ax - 1 = kp</p><p>ax - kp = 1</p><p>按前面方程的形式判断有解以及求解即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>差分约束系统</title>
    <link href="/2018/07/30/%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/"/>
    <url>/2018/07/30/%E5%9B%BE%E8%AE%BA/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="应用">1.应用</h1><p>用图论的方法求解一个每个式子只有两个元的不等式组。 # 2.求法之所以差分约束系统可以通过图论的最短路来解，是因为xj-xi&lt;=bk，会发现它类似最短路中的三角不等式d[v]&lt;=d[u]+w[u,v]，即d[v]-d[u]&lt;=w[u,v]。而求取最值的过程类似于最短路算法中的松弛过程。那么此时问题就已经转化为一个完全的图论问题了，该图论问题的解即为原问题的解，该图论问题无解即原问题无解，易得最短路无解条件为存在负环，即原问题无解条件为存在负环。## 负环 ### 定义是一个环，且权值和为负数。当存在负环则此图不存在最短路。 ### 找法使用spfa找 bfs版spfa：判定条件为一个点更新超过n次。dfs版spfa：判定条件为一个点重复更新（回溯记得清标记）。通常dfs比bfs快，但最坏情况下bfs更稳定。</p><h1 id="例题">3.例题</h1><p><a href="https://www.luogu.org/problemnew/show/P1993">小k的农场</a>（luogu）</p>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小生成树</title>
    <link href="/2018/07/30/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <url>/2018/07/30/%E5%9B%BE%E8%AE%BA/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="定义">1.定义</h1><p>在一给定的无向图G = (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v的边（即），而 w(u, v) 代表此边的权重，若存在 T 为 E的子集（即）且为无循环图，使得 的 w(T) 最小，则此 T 为 G的最小生成树。</p><p>用处例如：要在n个城市之间铺设光缆，主要目标是要使这 n个城市的任意两个之间都可以通信，但铺设光缆的费用很高，且各个城市之间铺设光缆的费用不同，因此另一个目标是要使铺设光缆的总费用最低。这就需要找到带权的最小生成树。</p><h1 id="求法">2.求法</h1><p>核心是贪心，每次选择最短的且目前不联通的两点间一条边建，然后标记已经联通，具体的方式是并查集。即kruskal算法。</p><h1 id="正确性的证明">3.正确性的证明</h1><p>** 第一步，我们证明按照kruskal算法操作一定能得到一颗生成树。 **</p><p>假设该算法得到的不是生成树，根据树的定义，就有两种情形，第一是得到的图是有环的，第二就是得到的图是不连通的。由于算法要求每次加入边都是无环的，所以第一种情形不存在，下面就只需证明第二种情形不存在即可。</p><p>假设得到的图是不连通的，则至少包含两个独立的的边集，假设其中一个为E，则E中边对应的所有点都无法到达其它边集对应的点（否则，根据算法定义，相应的联系边应被加入树中），而这与原图是连通的产生矛盾，因此，第二种情形也不可能存在。得证。</p><p>** 然后，我们证明这颗生成树是最小生成树。 **</p><p>假设图有n个顶点，则生成树一定具有n-1条边.由于图的生成树个数是有限的，所以至少有一棵树具有最小代价，假设该树为U。先做出如下假设：</p><p>1)得到的树为T。</p><p>2)U和T中不同的边的条数为k,其它n-1-k条边相同，这n-1-k条边构成边集E。；</p><p>3)在T中而不在U中的边按代价从小到大依次为a1，a2，...，ak。</p><p>4)在U中而不在T中的边按代价从小到大依次为x1，x2，...，xk。</p><p>现在我们通过把U转换为T（把T的边依次移入U中），来证明U和T具有相同代价。</p><p>首先，我们将a1移入U中，由于U本身是一棵树，此时任意加一条边都构成回路，所以a1的加入必然产生一条回路，且这条回路必然包括x1，x2，...，xk中的边。（否则a1与E中的边构成回路，而E也在T中，这与T中无回路矛盾。）在这个回路中删除属于x1，x2，...，xk且代价最大边xi构成一个新的生成树V。</p><p>假设a1代价小于xi，则V的代价小于U，这与U是最小代价树矛盾，所以a1不可能小于xi。</p><p>假设a1大于xi，按照Kruskal算法，首先考虑代价小的边，则执行Kruskal算法时，xi应该是在a1之前考虑，而a1又在a2，...，ak之前考虑，所以考虑xi之前，T中的边只能是E中的边，而xi既然没加入树T，就说明xi必然与E中的某些边构成回路，但xi和E又同时在U中，这与U是生成树矛盾，所以a1也不可能大于xi。</p><p>因此，新得到的树V与T具有相同代价。</p><p>依次类推，把a1，a2，...，ak的边逐渐加到U中，最终得到的树（T)与U代价相同。</p><p>证明结束。</p>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉路径与欧拉回路</title>
    <link href="/2018/07/30/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/"/>
    <url>/2018/07/30/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="定义">1.定义</h1><p>欧拉路径：指从某一点出发，走过所有的边一次到达终点。欧拉回路：是一种特殊的欧拉路径，其起点和终点重合。 # 2.判断有无 ##第一步：检查图的连通性 方法有：dfs，bfs，并查集推荐使用dfs，染色法，从每个点出发dfs，记联通块个数注意，有向图当作无向图来跑。一个trick：使用vector存无向图时，把边从0开始编号，互为相反边的挨着存，使用时找相反边用原边xor1即可。## 第二步：通过度数判断是否存在欧拉路径/欧拉回路 ### 无向图对于无向图，存在欧拉回路的充分必要条件为：所有点的度数均为偶数。感性理解一下： 必要性：因为进去多少次就要出来多少次，故必为偶数。充分性：此时图可看作若干个环组合，而环视一定有欧拉回路的，故整个图有欧拉回路。存在欧拉路径的充分必要条件为：所有点度数为偶数或仅存在两个点度数为基数，其余点度数为偶数。因为若在这两点间连一条辅助边，由无向图欧拉回路判定条件，此图必存在欧拉回路，断掉这条边即退化为欧拉路径。### 有向图对于有向图，存在欧拉回路的充分必要条件为：每个点的入度等于出度。因为有进必有出。存在欧拉路径的充分必要条件为：最多有一点入度等于出度+1，最多有一点入度等于出度-1，就会有一条从出度大于入度（没有则等于）的点出发，到达出度小于入度（没有则等于）的点的一条欧拉路径。与无向图的欧拉路径一样理解。# 3.找欧拉路径/欧拉回路 前提条件：已经确定存在欧拉路径/欧拉回路基本方法：dfs；欧拉回路可从任意一个点开始dfs，欧拉路径从起点开始，在回溯的时候将边压入结果栈，最后按栈序输出即可。主要是利用了dfs回溯的性质，不怕走死胡同，会把死胡同留到最后，相当于没有走死。时间复杂度：O(nm) ### 优化用一个数组记录每个点搜到了第几条边，然后从这里开始搜。空间复杂度：O(n+m) # 4.例题 <ahref="https://www.luogu.org/problemnew/show/P2731">骑马修栅栏</a>（luogu）</p>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧拉筛</title>
    <link href="/2018/07/30/%E6%95%B0%E8%AE%BA/%E6%AC%A7%E6%8B%89%E7%AD%9B/"/>
    <url>/2018/07/30/%E6%95%B0%E8%AE%BA/%E6%AC%A7%E6%8B%89%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<p>线性筛，复杂度为O(n)。与埃氏筛相比，不会对已经被标记过的合数再进行重复标记，故效率更高。欧拉筛将合数分解为(最小质因数 * 一个合数)的形式，通过最小质因数来判断当前合数是否已经被标记过。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">101</span>;   <span class="hljs-comment">// 表长</span><br><span class="hljs-type">int</span> prime[maxn], pNum = <span class="hljs-number">0</span>;    <span class="hljs-comment">// prime记录素数，pNum记录素数个数 </span><br><span class="hljs-type">bool</span> p[maxn] = &#123;<span class="hljs-literal">false</span>&#125;;        <span class="hljs-comment">// p记录当前数是否被筛去</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">eulerSieve</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>    <span class="hljs-comment">// 查找记录2-n的素数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (p[i] == <span class="hljs-literal">false</span>)  <span class="hljs-comment">// 如果未被筛过，则为素数</span><br>            prime[pNum++] = i;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; pNum; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i * prime[j] &gt; n)      <span class="hljs-comment">// 当要标记的合数超出范围时跳出</span><br>                <span class="hljs-keyword">break</span>;<br>            p[i * prime[j]] = <span class="hljs-literal">true</span>;     <span class="hljs-comment">// 将已经记录的素数的倍数进行标记</span><br>            <span class="hljs-keyword">if</span> (i % prime[j] == <span class="hljs-number">0</span>)      <span class="hljs-comment">//关键步骤</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>欧拉筛的难点就在于对if (i % prime[j] ==0)这步的理解，当i是prime[j]的整数倍时，记 m = i / prime[j]，那么 i *prime[j+1] 就可以变为 (m * prime[j+1]) * prime[j]，这说明 i * prime[j+1]是 prime[j] 的整数倍，不需要再进行标记(在之后会被 prime[j] * 某个数标记)，对于 prime[j+2]及之后的素数同理，直接跳出循环，这样就避免了重复标记。</p>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基本公式</title>
    <link href="/2018/07/30/%E6%95%B0%E8%AE%BA/%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/"/>
    <url>/2018/07/30/%E6%95%B0%E8%AE%BA/%E5%9F%BA%E6%9C%AC%E5%85%AC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>a|b b|c =&gt; a|c a|b a|c =&gt; a|(b<em>x+c</em>y) a|b =&gt; am|bma|n b|n gcd(a,b)=1 =&gt; ab|n 同余定理</p>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
      <tag>数论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>逆序对</title>
    <link href="/2018/07/30/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E9%80%86%E5%BA%8F%E5%AF%B9/"/>
    <url>/2018/07/30/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="求法">1.求法</h1><h2 id="法一">法一</h2><p>归并排序。 归并排序用到了二分的思想，在排序过程中如果a[ i ]&lt;=a[ j]就不会产生逆序对，如果a[ i ]&gt;a[ j]就会产生mid-i+1个逆序对，因为做归排的时候l～mid和mid+1～r都是已经排好序的所以如果a[i ]&gt;a[ j ]那么a[ i+1 ]~a[ mid ]也就都大于a[ j ] ## 法二 树状数组。首先我们只关心两个数之间的大小关系，其具体数值并不重要，所以为了方便处理，我们将输入的n个数进行离散化，即按照大小关系把a[1]到a[n]映射到1到num之间的数，为了保证原有的大小关系，其中num为不同的数字的个数。这样本题的描述方式可以换为：对于a[i]求a[i]后面有多少个数比它小？于是我们可以用树状数组来解决：我们从第n个数开始倒序处理，用树状数组的方法维护一个cnt数组，其query(x)前缀和表示到当前处理的第i个数为止,映射后值在1到x之间的数一共有几个。如果a[i]映射后的值为y，那么比a[i]小的个数就等于query(y-1)对于维护，只需要在该次查询结束后再y这个位置执行树状数组的修改操作即可。整个算法的复杂度为 nlongn</p><h1 id="应用">2.应用</h1><p>1.逆序对个数=这个数后面比它小的数个数。2.逆序对个数=这个数邻项交换到顺序位置时的操作次数。3.可用于求平均值不小于M的子段个数（前缀和顺序对）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>OI</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
